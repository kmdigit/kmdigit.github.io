<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Fun Programm Life</title>
    <link>https://kmdigit.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>funfun programmer life</description>
    <pubDate>Wed, 08 Apr 2020 09:07:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Algorithm :: 집합의 표현 (union-find)</title>
      <link>https://kmdigit.github.io/2020/04/08/algorithm-representation-of-a-set-union-find/</link>
      <guid>https://kmdigit.github.io/2020/04/08/algorithm-representation-of-a-set-union-find/</guid>
      <pubDate>Wed, 08 Apr 2020 05:14:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;백준 문제 : &lt;a href=&quot;https://www.acmicpc.net/problem/1717&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;(1717) 집합의 표현&lt;/a&gt;&lt;br&gt;알고리즘 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Union-Find&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;문제-정리&quot;&gt;&lt;a href=&quot;#문제-정리&quot; class=&quot;headerlink&quot; title=&quot;문제 정리&quot;&gt;&lt;/a&gt;문제 정리&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;집합 n+1개 ({0},{1},{2},…{n})&lt;/li&gt;
&lt;li&gt;첫 줄에 n과 m이 주어짐&lt;/li&gt;
&lt;li&gt;n은 집합의 개수이며 m은 라인&lt;/li&gt;
&lt;li&gt;각 라인은 [0 1(a) 3(b)], [1 7 1]가 같이 3개의 숫자를 전달&lt;/li&gt;
&lt;li&gt;맨 앞의 숫자 0은 a와 b를 합치며 1은 두 집합이 같은 집합인지 판단하여 “YES, “NO”를 출력
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>백준 문제 : <a href="https://www.acmicpc.net/problem/1717" rel="external nofollow noopener noreferrer" target="_blank">(1717) 집합의 표현</a><br>알고리즘 : <a href="https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0" rel="external nofollow noopener noreferrer" target="_blank">Union-Find</a></p></blockquote><h2 id="문제-정리"><a href="#문제-정리" class="headerlink" title="문제 정리"></a>문제 정리</h2><ol><li>집합 n+1개 ({0},{1},{2},…{n})</li><li>첫 줄에 n과 m이 주어짐</li><li>n은 집합의 개수이며 m은 라인</li><li>각 라인은 [0 1(a) 3(b)], [1 7 1]가 같이 3개의 숫자를 전달</li><li>맨 앞의 숫자 0은 a와 b를 합치며 1은 두 집합이 같은 집합인지 판단하여 “YES, “NO”를 출력<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">입력 출력</span><br><span class="line">7 8  NO</span><br><span class="line">0 1 3NO</span><br><span class="line">1 1 7YES</span><br><span class="line">0 7 6</span><br><span class="line">1 7 1</span><br><span class="line">0 3 7</span><br><span class="line">0 4 2</span><br><span class="line">0 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure></li></ol><h2 id="문제-해석"><a href="#문제-해석" class="headerlink" title="문제 해석"></a>문제 해석</h2><ol><li>초기에 주어지는 n은 makeset으로 서로소 집합으로 초기화 한다.</li><li>1이 주어질 때마다 각 루트를 찾아야 하므로 <code>union-find</code> 알고리즘을 사용하여 해결한다.</li></ol><h3 id="Brute-force"><a href="#Brute-force" class="headerlink" title="Brute force"></a>Brute force</h3><p>문제를 읽고 제일 쉽게 접근할 수 있는건 <code>Linked List</code> 일 것이다. <code>Linked List</code>는 내부에 다음 노드에 대한 정보를 갖고 있기 때문에 다음 노드를 참조하여 쉽게 루트까지 접근할 수 있다. 하지만 문제에서 주어지 듯 노드의 개수가 많아지면 많아질 수록 이 방법으론 원하는 속도로 해결하기 쉽지 않은데 Linked List로 해결할 때 시간 복잡도가 <code>O(n)</code>이기 때문이다.</p><h3 id="union-find"><a href="#union-find" class="headerlink" title="union-find"></a>union-find</h3><p>집합들을 합치고 그 집합들의 루트를 쉽게 찾을 수 있는 자료구조이다. 이 자료구조는 두 개의 유용한 연산을 제공하는데 다음과 같다.</p><ul><li>find : 어떤 원소가 주어졌을 때 이 원소가 속한 집합을 반환</li><li>union : 두 개의 집합을 하나의 집합으로 합침</li></ul><p><code>union-find</code>는 트리로 표현되는 자료구조이며 최적화까지 적용한 시간복잡도는 <code>O(logn)</code>으로 굉장히 빠른 속도를 보여줘 원하는 시간 내로 문제를 해결할 수 있다.</p><p><code>find(x)</code>는 주어진 원소의 루트(대표) 집합을 찾는 함수인데 루트가 자기 자신일 때까지 재귀함수를 통해 찾아나가며 이때 속도를 더 향상 시키기 위해 주어진 원소가 바로 루트를 바라볼 수 있게 값을 저장한다.</p><p><code>union(x, y)</code>는 <code>find</code>를 통해 얻어진 두 개의 루트끼리 비교하여 다를 경우 한 개의 집합을 다른 집합의 일부로 저장하도록 한다. 특별한 기준없이 저장할 경우 한 쪽의 트리가 너무 커지기 때문에 트리의 깊이를 맞춰줄 수 있도록 기능을 추가하면 더 빠르게 탐색이 가능하다. (여기서는 특별히 다루지 않는다)</p><h2 id="문제-소스"><a href="#문제-소스" class="headerlink" title="문제 소스"></a>문제 소스</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = readLine()!!.split(<span class="string">" "</span>).map &#123; it.toInt() &#125;</span><br><span class="line">    <span class="keyword">val</span> dt = IntArray(n + <span class="number">1</span>) &#123; it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dt[x] == x) <span class="keyword">return</span> x</span><br><span class="line">        dt[x] = find(dt[x])</span><br><span class="line">        <span class="keyword">return</span> dt[x]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">union</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        dt[find(y)] = find(x)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    repeat(m) &#123;</span><br><span class="line">        <span class="keyword">val</span> (cmd, a, b) = readLine()!!.split(<span class="string">" "</span>).map &#123; it.toInt() &#125;</span><br><span class="line">        <span class="keyword">when</span>(cmd) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; union(a, b)</span><br><span class="line">            <span class="number">1</span> -&gt; println(<span class="keyword">if</span> (find(a) == find(b)) <span class="string">"YES"</span> <span class="keyword">else</span> <span class="string">"NO"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>readLine()!!.split(&quot; &quot;).map{ it.toInt() }</code>는 라인으로 들어오는 INPUT 데이터를 정수형 타입으로 변환</li><li><code>IntArray(n + 1) { it }</code>는 <code>makeset</code>으로 서로소 집합으로 초기화 하는 작업</li><li><code>find, union</code>는 <code>union-find</code>를 구현하기 위한 기본 함수들</li></ul>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/04/08/algorithm-representation-of-a-set-union-find/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Algorithm :: Maximum Subarray</title>
      <link>https://kmdigit.github.io/2020/04/06/algorithm-maximum-subarray/</link>
      <guid>https://kmdigit.github.io/2020/04/06/algorithm-maximum-subarray/</guid>
      <pubDate>Mon, 06 Apr 2020 08:02:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Maximum-Subarray&quot;&gt;&lt;a href=&quot;#Maximum-Subarray&quot; class=&quot;headerlink&quot; title=&quot;Maximum Subarray&quot;&gt;&lt;/a&gt;Maximum Subarray&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;[Leetcode :: Maximum Subarray]&lt;/a&gt;&lt;br&gt;정수 배열 &lt;code&gt;nums&lt;/code&gt;를 지정하면 합계가 가장 큰 연속적인 하위 배열(최소 1개를 포함)을 찾아 합계를 반환하십시오.&lt;/p&gt;
&lt;h2 id=&quot;접근-방법&quot;&gt;&lt;a href=&quot;#접근-방법&quot; class=&quot;headerlink&quot; title=&quot;접근 방법&quot;&gt;&lt;/a&gt;접근 방법&lt;/h2&gt;&lt;h3 id=&quot;Brute-Force&quot;&gt;&lt;a href=&quot;#Brute-Force&quot; class=&quot;headerlink&quot; title=&quot;Brute Force&quot;&gt;&lt;/a&gt;Brute Force&lt;/h3&gt;&lt;p&gt;주어지는 배열은 &lt;code&gt;A = [-2, 1, -3, 4, -1, 2, 1, -5, 4]&lt;/code&gt;로 구성돼 있다.&lt;br&gt;문제를 보면 하나의 배열안에 하위 배열들의 합을 구하는 것이라 단순하게 생각해도 반복문 2개로 풀 수 있을 것이다. &lt;code&gt;A[0]&lt;/code&gt;부터 시작되는 하위 배열들부터 &lt;code&gt;A[1]~A[N-1]&lt;/code&gt;로 시작하는 하위 배열들의 합 중에서 제일 큰 걸 고르면 되는데 이렇게 작성을 하면 시간 복잡도는 O(n^2^)으로 너무 느려진다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p><a href="https://leetcode.com/problems/maximum-subarray/" rel="external nofollow noopener noreferrer" target="_blank">[Leetcode :: Maximum Subarray]</a><br>정수 배열 <code>nums</code>를 지정하면 합계가 가장 큰 연속적인 하위 배열(최소 1개를 포함)을 찾아 합계를 반환하십시오.</p><h2 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>주어지는 배열은 <code>A = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code>로 구성돼 있다.<br>문제를 보면 하나의 배열안에 하위 배열들의 합을 구하는 것이라 단순하게 생각해도 반복문 2개로 풀 수 있을 것이다. <code>A[0]</code>부터 시작되는 하위 배열들부터 <code>A[1]~A[N-1]</code>로 시작하는 하위 배열들의 합 중에서 제일 큰 걸 고르면 되는데 이렇게 작성을 하면 시간 복잡도는 O(n^2^)으로 너무 느려진다.</p><a id="more"></a><h3 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h3><p><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" rel="external nofollow noopener noreferrer" target="_blank"><code>Maximum subarray problem</code></a>이라고 구글에 검색해보면 위키피디아에서 카데인 알고리즘을 설명한다. 이 카데인 알고리즘은 기존에 반복문 2개로 작성되는 시간복잡도를 낮출 수 있는 방법으로 <code>DP</code>의 일종이다. 전체적인 시간복잡도는 <code>O(n)</code>으로 배열의 원소 갯수만큼만이기 때문에 속도도 굉장히 빠르다. 단점이라고 하면 단순히 최대값을 저장하는 메모리 정도?</p><p>카데인 알고리즘은 일종의 <code>DP</code>이므로 이전 계산의 결과값을 저장하고 이를 활용하도록 돼 있다. 아래 그림이 카데인 알고리즘을 잘 설명하는 그림이다.</p><p><img src="/images/pasted-4.png" alt="카데인 알고리즘"></p><p>예를 들어 A[5]인 -1은 A[0]의 4번째까지의 합의 결과에 합을 한 결과다. 마찬가지로 A[2]나 A[4]도 그 전까지의 합의 결과에 합을 하고 있다. 즉, 반복문 2번 돌면서 매번 결과값을 계산하지 않고 그 전 값을 어디에(이게서는 일반 변수에) 저장하여 그 값을 참조할 수만 있다면 빠른 계산이 가능하다.</p><p>여기에 각 값을 합한것만 저장하지 않고 합한 값에 현재 값을 비교(음수 중에서도 최소의 음수를 구하기 위해)하여 최대값을 유지한 채 지금까지의 최대값과 비교하여 그 최대값을 반환하면 부분 배열의 최대 합계값을 구할 수 있다.</p><h3 id="최종-결과"><a href="#최종-결과" class="headerlink" title="최종 결과"></a>최종 결과</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;        </span><br><span class="line">        <span class="keyword">var</span> bestSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> currentSum = nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">            currentSum = maxOf(nums[i], currentSum + nums[i])</span><br><span class="line">            bestSum = maxOf(bestSum, currentSum)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bestSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-5.png" alt="leetcode 결과"></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/04/06/algorithm-maximum-subarray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Kotlin :: 클래스, 객체, 인터페이스 2</title>
      <link>https://kmdigit.github.io/2020/04/03/second-class-object-interface/</link>
      <guid>https://kmdigit.github.io/2020/04/03/second-class-object-interface/</guid>
      <pubDate>Thu, 02 Apr 2020 23:58:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://kmdigit.github.io/2020/03/30/first-class-object-interface/&quot;&gt;클래스, 객체, 인터페이스 1&lt;/a&gt;에 이어 클래스, 객체, 인터페이스2 를 시작한다.&lt;/p&gt;
&lt;h2 id=&quot;클래스-선언&quot;&gt;&lt;a href=&quot;#클래스-선언&quot; class=&quot;headerlink&quot; title=&quot;클래스 선언&quot;&gt;&lt;/a&gt;클래스 선언&lt;/h2&gt;&lt;p&gt;코틀린에서는 생성자를 &lt;code&gt;주 생성자(primary constructor)&lt;/code&gt;와 &lt;code&gt;부 생성자(secondary constructor)&lt;/code&gt;로 나눈다. 주 생성자는 단 한번만 선언할 수 있으며 부 생성자를 여럿 선언할 수도 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://kmdigit.github.io/2020/03/30/first-class-object-interface/">클래스, 객체, 인터페이스 1</a>에 이어 클래스, 객체, 인터페이스2 를 시작한다.</p><h2 id="클래스-선언"><a href="#클래스-선언" class="headerlink" title="클래스 선언"></a>클래스 선언</h2><p>코틀린에서는 생성자를 <code>주 생성자(primary constructor)</code>와 <code>부 생성자(secondary constructor)</code>로 나눈다. 주 생성자는 단 한번만 선언할 수 있으며 부 생성자를 여럿 선언할 수도 있다.</p><a id="more"></a><h3 id="클래스-초기화-주-생성자와-초기화-블럭"><a href="#클래스-초기화-주-생성자와-초기화-블럭" class="headerlink" title="클래스 초기화: 주 생성자와 초기화 블럭"></a>클래스 초기화: 주 생성자와 초기화 블럭</h3><p>코틀린에서 제공하는 주 생성자는 클래서 선언과 동시에 이뤄진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)</span><br></pre></td></tr></table></figure><p>보통 클래스의 모든 선언은 중괄호({}) 사이에 들어가지만 코틀린의 주 생성자는 클래스 이름 뒤에 괄호로 선언한다. 주 생성자는 <code>생성자 파라미터를 지정</code>하고 그 생성자 파라미터에 의해 <code>초기화되는 프로퍼티를 정의</code>하는 두 가지 목적에 쓰인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String) &#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    nickname = _nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor, init 생략 가능</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(_nickname: String) &#123;</span><br><span class="line">  <span class="keyword">val</span> nickname = _nickname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>constrcutor 키워드</code>는 주 생성자나 부 생성자를 정의할 때 사용한다.</li><li><code>init 키워드</code>는 초기화 블록을 시작한다.</li></ul><p>생성자에는 <code>디폴트 파라미터를 설정</code>할 수 있으며 객체 생성시 이름도 지정 가능하다. 또한 모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 <code>파라미터가 없는 생성자</code>를 만들어 주기도 한다.</p><p>클래스를 상속할 땐 꼭 부모 클래스의 주 생성자를 호출해야 한다. 아래와 같이 말이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String) &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwitterUser</span></span>(nickname: String): User(nickname) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>위와 같이 클래스를 상속하게 되면 주 생성자를 호출해야 하므로 상속받는 <code>클래스명 뒤에 괄호</code>를 사용해야 한다. 하지만 인터페이스는 생성자가 없으므로(실제로는 클래스가 private) 인터페이스를 상속받을 땐 <code>괄호를 사용하지 않고 선언</code>할 수 있다. 그러므로 어떤 클래스가 2개의 클래스를 상속받는 데 하나는 괄호가 있고 하나는 괄호가 없다면 <code>괄호 있는 이름이 클래스</code>이며 <code>괄호 없는 이름이 인터페이스</code>로 구분이 쉽게 가능하다.</p><h2 id="인터페이스-프로퍼티-구현"><a href="#인터페이스-프로퍼티-구현" class="headerlink" title="인터페이스 프로퍼티 구현"></a>인터페이스 프로퍼티 구현</h2><p>코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다. 또한 프로퍼티의 구현도 가능하여 아래와 같이 작성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String) : User</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribingUser</span></span>(<span class="keyword">val</span> email: String) : User(</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname: String</span><br><span class="line">    <span class="keyword">get</span>() = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> accountId: <span class="built_in">Int</span>): User &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname = getFacebookName(accoundId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PrivateUser은 주 생성자 안에 프로퍼티를 직접 선언하는 방법을 선택하였다.</li><li>SubscribingUser는 nickname을 호출할 때마다 주 생성자에서 입력받은 email을 계산하여 반환한다.</li><li>FacebookUser는 초기화 구문으로 nickname에 getFacebookName 함수로 이름을 초기화 한다.</li></ul><h2 id="게터와-세터에서-뒷받침하는-필드에-접근"><a href="#게터와-세터에서-뒷받침하는-필드에-접근" class="headerlink" title="게터와 세터에서 뒷받침하는 필드에 접근"></a>게터와 세터에서 뒷받침하는 필드에 접근</h2><p>데이터 값이 변경 됨에 따라 어떤 값으로 변경했는지 알고 싶을 때 기존 값과 새로운 값의 로그를 작성하는데 이 로직을 세터에서 할 수 있도록 작성이 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">var</span> address: String = <span class="string">"unspecified"</span></span><br><span class="line">    <span class="keyword">set</span>(value: String) &#123;</span><br><span class="line">      println(<span class="string">"""</span></span><br><span class="line"><span class="string">Address was changed for <span class="variable">$name</span>:</span></span><br><span class="line"><span class="string">"<span class="variable">$field</span>" -&gt; "<span class="variable">$value</span>"."""</span>.trimIndent())</span><br><span class="line">      field = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로퍼티에서 원래의 값을 접근할 땐 <code>field</code>식별자를 사용하여 접근이 가능하다.</p><h2 id="접근자의-가시성-변경"><a href="#접근자의-가시성-변경" class="headerlink" title="접근자의 가시성 변경"></a>접근자의 가시성 변경</h2><p>접근자의 가시성은 기본적으로 프로퍼티 가시성과 같으며 <code>private</code>으로 작성 시 외부에서는 해당 접근자에 접근을 못하지만 내부에서는 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthCounter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">addWord</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    counter += word.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/04/03/second-class-object-interface/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Regex :: 유용한 정규표현식 샘플 with Java</title>
      <link>https://kmdigit.github.io/2020/04/01/useful-regex-sample/</link>
      <guid>https://kmdigit.github.io/2020/04/01/useful-regex-sample/</guid>
      <pubDate>Wed, 01 Apr 2020 12:08:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;정규표현식&quot;&gt;&lt;a href=&quot;#정규표현식&quot; class=&quot;headerlink&quot; title=&quot;정규표현식&quot;&gt;&lt;/a&gt;정규표현식&lt;/h2&gt;&lt;p&gt;정규 표현식(正規表現式, 영어: regular expression, 간단히 regexp 또는 regex, rational expression) 또는 정규식(正規式)은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 정규 표현식은 많은 텍스트 편집기와 프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있으며, 특히 펄과 Tcl은 언어 자체에 강력한 정규 표현식을 구현하고 있다. (출처 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;위키피디아&lt;/a&gt;)&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="정규표현식"><a href="#정규표현식" class="headerlink" title="정규표현식"></a>정규표현식</h2><p>정규 표현식(正規表現式, 영어: regular expression, 간단히 regexp 또는 regex, rational expression) 또는 정규식(正規式)은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 정규 표현식은 많은 텍스트 편집기와 프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있으며, 특히 펄과 Tcl은 언어 자체에 강력한 정규 표현식을 구현하고 있다. (출처 : <a href="https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D" rel="external nofollow noopener noreferrer" target="_blank">위키피디아</a>)</p><a id="more"></a><h2 id="샘플"><a href="#샘플" class="headerlink" title="샘플"></a>샘플</h2><p>문자열을 다루다보면 정규표현식을 무조건 써야 하는 상황이 생기는데 매번 검색하고 정규표현식 표를 펴놓고 만들기 힘들어서(귀찮아서) 정리 해본다.</p><h3 id="Whitespace-삭제"><a href="#Whitespace-삭제" class="headerlink" title="Whitespace 삭제"></a>Whitespace 삭제</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replaceAll(<span class="string">"\\s+"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><h3 id="알파벳-및-특수문자-삭제"><a href="#알파벳-및-특수문자-삭제" class="headerlink" title="알파벳 및 특수문자 삭제"></a>알파벳 및 특수문자 삭제</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replaceAll(<span class="string">"[\\s+a-zA-Z :%]"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>이 예제에서 특수문자 삭제는 <code>:%</code>이다.</p><h3 id="숫자를-제외한-모든-것을-삭제"><a href="#숫자를-제외한-모든-것을-삭제" class="headerlink" title="숫자를 제외한 모든 것을 삭제"></a>숫자를 제외한 모든 것을 삭제</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replaceAll(<span class="string">"[^\\d]"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/04/01/useful-regex-sample/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker :: 중지 된 모든 컨테이너 한 번에 삭제하기</title>
      <link>https://kmdigit.github.io/2020/03/31/remove-all-container-that-status-is-exited/</link>
      <guid>https://kmdigit.github.io/2020/03/31/remove-all-container-that-status-is-exited/</guid>
      <pubDate>Tue, 31 Mar 2020 09:02:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h2&gt;&lt;p&gt;데브옵스 한다고 CI/CD 구축해놓고 Release 브랜치에 푸시 할 때 태그정보로 이미지를 만들고 그대로 컨테이너로 생성하여 특정 호스트에 배포를 하고 있었다. 개발기였기 때문에 별 문제 없이 사용했었는데 우연찮게 도커 클라이언트에 있는 컨테이너 정보를 모두 호출했다가 중지 된 수십 개의 컨테이너가 있는 걸 발견했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>데브옵스 한다고 CI/CD 구축해놓고 Release 브랜치에 푸시 할 때 태그정보로 이미지를 만들고 그대로 컨테이너로 생성하여 특정 호스트에 배포를 하고 있었다. 개발기였기 때문에 별 문제 없이 사용했었는데 우연찮게 도커 클라이언트에 있는 컨테이너 정보를 모두 호출했다가 중지 된 수십 개의 컨테이너가 있는 걸 발견했다.</p><a id="more"></a><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><p>컨테이너 실행 시 <code>--rm</code> 옵션을 안 넣었다. 아.. 컨테이너가 중지될 때 자동으로 삭제하게 만들었어야 했는데 얼마나 미련한가..<br>결국 이로인해 배포할 때마다 중지 된 컨테이너가 줄줄이 중지된 채 남아있었던 것이다.</p><h2 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h2><p><code>docker rm</code> 명령어로 삭제를 하면 되는데 일일이 컨테이너 명 혹은 아이디를 넣어 삭제하는 건 너무나 힘들고 귀찮은 일이다. 그래서 아래 명령어로 한 번에 다 삭제했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -f status=exited -q)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/31/remove-all-container-that-status-is-exited/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 배포 시 Contribution이 올라가지 않을 때</title>
      <link>https://kmdigit.github.io/2020/03/30/set-specific-git-user-email/</link>
      <guid>https://kmdigit.github.io/2020/03/30/set-specific-git-user-email/</guid>
      <pubDate>Mon, 30 Mar 2020 12:12:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h2&gt;&lt;p&gt;1일 1커밋을 실천하다가 우연찮게 내 Github 페이지를 봤는데 이상하게 Contribution에 예쁜 녹색이 찍혀있지 않은 걸 발견했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-1.png&quot; alt=&quot;아.. 부끄러운 내 기록..&quot;&gt;&lt;/p&gt;
&lt;p&gt;최소한 끝에 녹색이 연속적으로 찍혔어야 했는데 찍히지 않은걸 발견하고 뭔가 잘못된 걸 직감했고 나는 바로 그 원인를 찾아야 했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>1일 1커밋을 실천하다가 우연찮게 내 Github 페이지를 봤는데 이상하게 Contribution에 예쁜 녹색이 찍혀있지 않은 걸 발견했다.</p><p><img src="/images/pasted-1.png" alt="아.. 부끄러운 내 기록.."></p><p>최소한 끝에 녹색이 연속적으로 찍혔어야 했는데 찍히지 않은걸 발견하고 뭔가 잘못된 걸 직감했고 나는 바로 그 원인를 찾아야 했다.</p><a id="more"></a><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h2><p>우선 매일 커밋하는 저장소의 커밋을 확인했더니 <em>어라?</em> 회사에서 사용하는 아이디로 push가 돼 있는거 아닌가!</p><p><img src="/images/pasted-2.png" alt="내 개인 저장소에 회사를 뭍혀버렸다."></p><p>단번에 그 원인을 발견했다. 바로 내 github에 등록돼 있는 메일로 push를 하지 않아서였다.</p><p>매일 올리던 저장소의 루트에서 <code>git config -l</code>을 해보니 <code>user.name과 user.email</code>이 회사 계정으로 돼 있었다. 아마 회사에서도 git을 사용하고 있어 global 설정이 회사 계정으로 된 것으로 보인다.</p><h2 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h2><p>원인는 확인했으니 바로 해결을 해보자. 해결은 굉장히 심플한테 github 저장소와 연결돼 있는 로컬 디렉토리의 루트에서 내가 github에 등록한 사용자 정보로 push할 수 있도록 설정하는 것이다. 저장소 루트 디렉토리에서 <code>git config</code> 명령어로 다음과 같이 설정한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"funlee"</span></span><br><span class="line">git config user.email <span class="string">"funlee@kakao.com"</span></span><br></pre></td></tr></table></figure><p>물론 여기서 사용하는 email은 github에 <code>로그인할 때 사용하는 계정</code>으로해야 한다.</p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/30/set-specific-git-user-email/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Kotlin] 클래스, 객체, 인터페이스 1</title>
      <link>https://kmdigit.github.io/2020/03/30/first-class-object-interface/</link>
      <guid>https://kmdigit.github.io/2020/03/30/first-class-object-interface/</guid>
      <pubDate>Mon, 30 Mar 2020 11:59:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;코틀린-인터페이스&quot;&gt;&lt;a href=&quot;#코틀린-인터페이스&quot; class=&quot;headerlink&quot; title=&quot;코틀린 인터페이스&quot;&gt;&lt;/a&gt;코틀린 인터페이스&lt;/h2&gt;&lt;p&gt;코틀린 인터페이스는 자바8과 비슷하게 추상 메소드 뿐만 아니라 구현이 있는 메소드도 정의할 수 있다. 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Clickable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;showOff&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = println(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m clickable&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Button&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;Clickable &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = println(&lt;span class=&quot;string&quot;&gt;&quot;I&#39; was clicked&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;콜론(:)&lt;/code&gt;을 붙여 클래스 확장과 인터페이스를 구현 모두를 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt;변경자는 @Override 애노테이션과 동일하게 오버라이드 표시를 하지만 오버라이드 시 &lt;code&gt;반드시 사용&lt;/code&gt;해야 한다.&lt;/li&gt;
&lt;li&gt;showOff와 같이 &lt;code&gt;디폴트 함수&lt;/code&gt;를 제공한다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="코틀린-인터페이스"><a href="#코틀린-인터페이스" class="headerlink" title="코틀린 인터페이스"></a>코틀린 인터페이스</h2><p>코틀린 인터페이스는 자바8과 비슷하게 추상 메소드 뿐만 아니라 구현이 있는 메소드도 정의할 수 있다. 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm clickable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">Clickable &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">"I' was clicked"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>콜론(:)</code>을 붙여 클래스 확장과 인터페이스를 구현 모두를 처리한다.</li><li><code>override</code>변경자는 @Override 애노테이션과 동일하게 오버라이드 표시를 하지만 오버라이드 시 <code>반드시 사용</code>해야 한다.</li><li>showOff와 같이 <code>디폴트 함수</code>를 제공한다.<a id="more"></a></li></ul><p>인터페이스는 자바와 동일하게 하나의 클래스가 여러 인터페이스를 구현할 수 있는데 동일한 인터페이스의 디폴트 함수가 있을 경우 코틀린에서는 컴파일 에러로 사용자에게 하위 클래스에 직접 구현하게 강제한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interfacle Focusable &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm focusable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable</span>, <span class="type">Focusable &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br><span class="line">    <span class="keyword">super</span>&lt;Focusable&gt;.showOff()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Clickable, Focusable의 <code>showOff</code>함수가 동일하므로 오버라이드 하였다.</li><li>상위 타입 호출 시 자바와는 다르게 <code>super&lt;&gt;</code>를 사용한다. (자바는 Clickable.super.showOff()처럼 호출한다)</li></ul><h2 id="기본적으로-final"><a href="#기본적으로-final" class="headerlink" title="기본적으로 final"></a>기본적으로 final</h2><p>코틀린에서는 자바와는 다르게 기본적으로 아무것도 명시하지 않을 시 모든 클래스와 함수는 <code>final</code>이다. 그 이유는 <code>취약한 기반 클래스(fragile base class)</code>라는 문제를 기반하기 때문이다. 이 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 즉 Effective Java에서처럼 <code>상속을 위한 설계와 문서를 갖추거나, 그럴수 없다면 상속을 금지하라</code>라는 철학을 따라 기본적으로 모두 <code>final</code>이다.</p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>어떤 클래스의 상속을 허용하려면 <code>open</code>변경자를 붙여야 한다. 함수도 마찬가지이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RightButton</span> : <span class="type">Clickable &#123;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>disable함수는 <code>오버라이드 불가</code>이다.</li><li>animate함수는 열려있으므로 <code>오버라이드 가능</code>이다.</li><li>click함수는 오버라이드 함수므로 <code>기본적으로 열려</code>있다.</li><li>RightButton클래스는 열려 있으므로 <code>상속이 가능</code>하다.</li></ul><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>추상 클래스를 정의할 땐 <code>abstract 변경자</code>를 사용한다. 추상 클래스 및 추상 멤버는 inteface와 동일하게 <code>기본적으로 모두 열려</code>있다. 그러므로 open 변경자를 명시할 필요가 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animated</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopAnimating</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">animateTwice</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>abstract 클래스이므로 <code>상속이 가능</code>하다.</li><li>animate함수는 추상함수이므로 <code>오버라이드가 가능</code>하다.</li><li>stopAnimating함수는 비추상 함수이지만 <code>open이므로 오버라이드가 가능</code>하다</li><li>animateTwice함수는 비추상 함수이므로 <code>오버라이드가 불가능</code>하다.</li></ul><h2 id="가시성-변경자-기본적으로-공개"><a href="#가시성-변경자-기본적으로-공개" class="headerlink" title="가시성 변경자 : 기본적으로 공개"></a>가시성 변경자 : 기본적으로 공개</h2><ul><li>아무 변경자도 없는 경우 선언은 모두 public이다.</li><li>internal 변경자는 모듈 내부에서만 볼 수 있음을 의미한다.</li><li>가시성은 public &gt; internal &gt; protected &gt; private 순서이다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span> : <span class="type">Fucosable &#123;</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">"Hey!"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">whisper</span><span class="params">()</span></span> = println(<span class="string">"Let's talk!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">giveSpeech</span><span class="params">()</span></span> &#123;</span><br><span class="line">  yell()</span><br><span class="line">  whisper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>giveSpeech 함수는 확장 함수로 public이 기본이므로 internal TalkativeButton 수신 타입을 <code>확장 할 수 없다</code>.</li><li>yell함수는 private이므로 public 함수에서 <code>접근이 불가능</code>하다.</li><li>whisper함수는 protected이므로 public함수에서 <code>접근이 불가능</code>하다.</li></ul></li></ul><h2 id="내부-inner-클래스와-중첩-nested-클래스-기본은-중첩"><a href="#내부-inner-클래스와-중첩-nested-클래스-기본은-중첩" class="headerlink" title="내부(inner) 클래스와 중첩(nested) 클래스 : 기본은 중첩"></a>내부(inner) 클래스와 중첩(nested) 클래스 : 기본은 중첩</h2><p>자바에서는 static 키워드를 사용하지 않고 클래스 내부에 클래스를 선언하면 기본적으로 내부(inner) 클래스로 선언된다. 내부 클래스는 외부 클래스를 모르게 참조하고 있어 만약 직렬화 시 원하는대로 작동되지 않을 수가 있다.</p><p>코틀린에서는 자바와는 다르게 내부에 클래스를 선언하게 되면 중첩(nested)클래스로 선언된다. 자바에서 static으로 선언한 내부 클래스와 똑같이 말이다. 만약 내부 클래스로 선언하려면 <code>inner</code>변경자를 붙여야 하며 내부에서 외부 클래스를 접근하려면 <code>this@클래스명</code>으로 접근해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOuterReference</span><span class="params">()</span></span> : Outer = <span class="keyword">this</span><span class="symbol">@Outer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="봉인된-클래스-sealed"><a href="#봉인된-클래스-sealed" class="headerlink" title="봉인된 클래스 : sealed"></a>봉인된 클래스 : sealed</h2><p>인터페이스로 선언한 클래스를 상속받은 클래스를 <code>when</code>구문으로 타입 검사를 할 경우 항상 <code>else</code>구문이 강제되어야 한다. 만약 인터페이스를 상속한 클래스를 해당 when구문에 추가하지 않는다면 else구문이 실행되므로 원하지 않는 에러가 발생할 수 있다. 코틀린에서는 이런 문제점을 해결하기 위해 <code>sealed</code>라는 변경자를 지원한다. 이 sealed 변경자는 클래스 계층 정의 시 계층 확장을 제한에 둔다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface로 상속받은 클래스 별 실행</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: <span class="built_in">Int</span>, <span class="keyword">val</span> right: <span class="built_in">Int</span>): Expr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">  <span class="keyword">when</span> (e) &#123;</span><br><span class="line">    <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown expression"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sealed클래스로 선언된 클래스 별 실행</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: <span class="built_in">Int</span>, <span class="keyword">val</span> right: <span class="built_in">Int</span>): Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span> =</span><br><span class="line">  <span class="keyword">when</span> (e) &#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Num -&gt; e.value</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>sealed 클래스 내부에 선언한 클래스들은 Expr 클래스를 상속받고 있어 when 구문에서 타입 검사가 이뤄지며 코틀린에서는 만약 Expr클래스를 상속받은 다른 클래스가 생기면 컴파일 에러로 사용자에게 알려준다. 또한 sealed 클래스는 상속이 가능하므로 open 클래스이며 기본으로 <code>open 변경자</code>를 갖고 있다.</p><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/30/first-class-object-interface/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수 정의와 호출 2</title>
      <link>https://kmdigit.github.io/2020/03/29/second-funtion-definition-and-call/</link>
      <guid>https://kmdigit.github.io/2020/03/29/second-funtion-definition-and-call/</guid>
      <pubDate>Sun, 29 Mar 2020 06:02:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://kmdigit.github.io/2020/03/28/first-funtion-definition-and-call/&quot;&gt;함수 정의와 호출 1&lt;/a&gt;에 이어 함수 정의와 호출 2를 시작한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;확장-프로퍼티&quot;&gt;&lt;a href=&quot;#확장-프로퍼티&quot; class=&quot;headerlink&quot; title=&quot;확장 프로퍼티&quot;&gt;&lt;/a&gt;확장 프로퍼티&lt;/h2&gt;&lt;p&gt;확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있다. 확장 프로퍼티로 작성하면 아무 상태도 가질 수 없지만 (확장 함수와 같다) 코드를 더 짧게 작성할 수 있어서 편한 경우가 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; String.lastChar: &lt;span class=&quot;built_in&quot;&gt;Char&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;() = &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;(length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://kmdigit.github.io/2020/03/28/first-funtion-definition-and-call/">함수 정의와 호출 1</a>에 이어 함수 정의와 호출 2를 시작한다.</p><hr><h2 id="확장-프로퍼티"><a href="#확장-프로퍼티" class="headerlink" title="확장 프로퍼티"></a>확장 프로퍼티</h2><p>확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있다. 확장 프로퍼티로 작성하면 아무 상태도 가질 수 없지만 (확장 함수와 같다) 코드를 더 짧게 작성할 수 있어서 편한 경우가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="가변-인자"><a href="#가변-인자" class="headerlink" title="가변 인자"></a>가변 인자</h2><p>코틀린과 자바에서의 가변 인자의 차이점은 두 가지이며 나머지는 모두 동일하다.</p><ul><li>자바에서는 …를 사용하지만 코틀린에서는 <code>vararg</code>를 파라미터 앞에 붙인다.</li><li>자바에서는 배열을 그대로 파라미터로 넘겼지만 코틀린에서는 스프레드(*)로 풀어서 넘겨야 한다.  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Arrays</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> list = listOf(<span class="string">"args: "</span>, *args)</span><br><span class="line">  println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="중위-호출"><a href="#중위-호출" class="headerlink" title="중위 호출"></a>중위 호출</h2><p>중위 호출은 수신 객체의 인자가 하나뿐인 일반 메소드나 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다. 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다. 이때 객체, 메소드 이름, 유일한 인자 사이에는 <code>공백</code>이 들어가야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.to(<span class="string">"one"</span>) <span class="comment">// &lt;- "to" 메소드를 일반적인 방식으로 호출함</span></span><br><span class="line"><span class="number">1</span> to <span class="string">"one"</span> <span class="comment">// &lt;- "to" 메소드를 중위 호출 방식으로 호출함</span></span><br></pre></td></tr></table></figure><h2 id="구조-분해-선언"><a href="#구조-분해-선언" class="headerlink" title="구조 분해 선언"></a>구조 분해 선언</h2><p>구조 분해 선언은 <code>Pair</code>와 같은 순서쌍을 표현하는 클래스에 대해 분해 후 즉시 초기화를 할 수 있는 기능을 얘기한다. 위에서 예를 들었던 <code>1 to &quot;one&quot;</code>은 그 결과가 <code>Pair</code>이다. 이 결과로 변수를 즉시 초기화 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (number, name) = <span class="number">1</span> to <span class="string">"one"</span></span><br></pre></td></tr></table></figure><h2 id="문자열과-정규식"><a href="#문자열과-정규식" class="headerlink" title="문자열과 정규식"></a>문자열과 정규식</h2><p>코틀린에서는 문자열의 split함수를 조금 더 다루기 쉽고 명확하게 할 수 있도록 노력했다. 코틀린 문자열의 split함수는 일반 문자열과 정규화 두 개를 모두 전달 받을 수 있는데 정규화의 경우 Regex 타입의 값만 받을 수 있도록 하였는데 <code>&quot;\\!|-&quot;.toRegex()</code>와 같은 방식으로 Regex 타입을 만든다.</p><p>정규화 문법을 작성 시 이스케이프 문자로 <code>\</code>을 넣는데 <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code>와 같이 <code>3중 따옴표</code>로 문자열을 묶을 경우 이스케이프 문자가 필요 없어 다음과 같이 정규화 문법을 작성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ParsePath</span><span class="params">(path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> regex = <span class="string">"""(.+)/(.+)\.(.+)"""</span>.toRegex()</span><br><span class="line">  <span class="keyword">val</span> matchResult = regex.matchEntire(path)</span><br><span class="line">  <span class="keyword">if</span> (matchResult != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> (directory, filename, extension) = matchResult.destructed</span><br><span class="line">    println(<span class="string">"Dir: <span class="variable">$directory</span>, name: <span class="variable">$filename</span>, ext: <span class="variable">$extension</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="로컬-함수와-확장"><a href="#로컬-함수와-확장" class="headerlink" title="로컬 함수와 확장"></a>로컬 함수와 확장</h2><p>코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 부가 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다. 자바에서는 함수 안에서 함수를 다시 정의하지 못하므로 클래스 내부에 같은 레벨의 함수로 정의하거나 별도의 내부 클래스로 함수를 넣어 사용하기도 하지만 코틀린은 함수 안에서 또 다른 함수를 선언할 수 있다. 아래는 그 예다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 일반적인 코드</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Name"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Address"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// user 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 로컬 함수 사용</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(user: <span class="type">User</span>, value: <span class="type">String</span>, field: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$field</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  validate(user, user.name, <span class="string">"Name"</span>)</span><br><span class="line">  validate(user, user.address, <span class="string">"Address"</span>)</span><br><span class="line">  <span class="comment">// user 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 바깥 함수 파라미터 접근</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, field: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$field</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  validate(user.name, <span class="string">"Name"</span>)</span><br><span class="line">  validate(user.address, <span class="string">"Address"</span>)</span><br><span class="line">  <span class="comment">// user 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 확장 함수로 변경</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Uuser.<span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, field: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Can't save user <span class="subst">$&#123;id&#125;</span>: empty <span class="variable">$field</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  validate(name, <span class="string">"Name"</span>)</span><br><span class="line">  validate(address, <span class="string">"Address"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">  user.validateBeforeSave()</span><br><span class="line">  <span class="comment">// user 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/29/second-funtion-definition-and-call/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수 정의와 호출 1</title>
      <link>https://kmdigit.github.io/2020/03/28/first-funtion-definition-and-call/</link>
      <guid>https://kmdigit.github.io/2020/03/28/first-funtion-definition-and-call/</guid>
      <pubDate>Sat, 28 Mar 2020 12:12:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;코틀린에서-컬렉션-만들기&quot;&gt;&lt;a href=&quot;#코틀린에서-컬렉션-만들기&quot; class=&quot;headerlink&quot; title=&quot;코틀린에서 컬렉션 만들기&quot;&gt;&lt;/a&gt;코틀린에서 컬렉션 만들기&lt;/h2&gt;&lt;p&gt;코틀린에서는 코틀린만의 컬렉션을 만들지 않고 모두 자바의 컬렉션은 그대로 사용하고 추가적인 함수를 제공하고 있다. 컬렉션을 만들 때엔 대체적으로 &lt;code&gt;컬렉션명 + Of&lt;/code&gt;의 조합이다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; = hashSetOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;53&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; list = arrayListOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;53&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; map = hashMapOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;string&quot;&gt;&quot;one&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; to &lt;span class=&quot;string&quot;&gt;&quot;seven&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;53&lt;/span&gt; to &lt;span class=&quot;string&quot;&gt;&quot;fifty-three&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; println(&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;.javaClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;HashSet&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; println(list.javaClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; println(map.javaClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="코틀린에서-컬렉션-만들기"><a href="#코틀린에서-컬렉션-만들기" class="headerlink" title="코틀린에서 컬렉션 만들기"></a>코틀린에서 컬렉션 만들기</h2><p>코틀린에서는 코틀린만의 컬렉션을 만들지 않고 모두 자바의 컬렉션은 그대로 사용하고 추가적인 함수를 제공하고 있다. 컬렉션을 만들 때엔 대체적으로 <code>컬렉션명 + Of</code>의 조합이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">"one"</span>, <span class="number">7</span> to <span class="string">"seven"</span>, <span class="number">53</span> to <span class="string">"fifty-three"</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(<span class="keyword">set</span>.javaClass)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashSet</span></span></span><br><span class="line">&gt;&gt;&gt; println(list.javaClass)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">ArrayList</span></span></span><br><span class="line">&gt;&gt;&gt; println(map.javaClass)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="이름-붙인-인자"><a href="#이름-붙인-인자" class="headerlink" title="이름 붙인 인자"></a>이름 붙인 인자</h2><p>최신의 몇몇 언어들은 함수에 전달하는 인자의 이름을 명시할 수 있도록 지원하고 있다. 코틀린 역시 마찬가지다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, separator: <span class="type">String</span>, prefix: <span class="type">String</span>, postfix: <span class="type">String</span>)</span></span></span><br><span class="line">joinToString(collection, separator = <span class="string">" "</span>, prefix = <span class="string">" "</span>, postfix = <span class="string">"."</span>)</span><br></pre></td></tr></table></figure><p>단 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 <code>뒤에 오는 모든 인자는 이름을 꼭 명시</code>해야 한다.</p><h2 id="디폴트-파라미터"><a href="#디폴트-파라미터" class="headerlink" title="디폴트 파라미터"></a>디폴트 파라미터</h2><p>CPP를 했던 사람에게 자바를 할 때 불편했던 점 한가지를 들자면 대부분 디폴트 파라미터 얘기가 나온다. 디폴트 파라미터는 함수의 파라미터에 기본 값을 설정 해줄 수 있는데 이렇게 되면 불필요한 함수 오버로딩을 줄일 수 있기 때문에 유용하게 사용하게 된다. 코틀린에서는 이와같이 유용하게 사용할 수 있는 디폴트 파라미터를 적용했다. 그리고 <code>이름 붙인 인자</code>와 같이 사용하게 되면 효용성은 더 높아진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">postfix: <span class="type">String</span> = <span class="string">""</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: String</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; joinToString(collection)</span><br><span class="line">&gt;&gt;&gt; joinToString(collection, <span class="string">"; "</span>)</span><br><span class="line">&gt;&gt;&gt; joinToString(collection, postfix = <span class="string">";"</span>, prefix = <span class="string">"# "</span>)</span><br></pre></td></tr></table></figure><p>만약 자바에서 코틀린 함수를 호출할 때 디폴트 파라미터로 구현돼 있을 경우 코틀린 함수에 <code>@JvmOverloads</code>애노테이션을 추가하면 자동으로 함수 오버로딩을 작성해준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">String joinToString(Collection&lt;T&gt; collection, String separator, String prefix, String postfix);</span><br><span class="line">String joinToString(Collection&lt;T&gt; collection, String separator, String prefix);</span><br><span class="line">String joinToString(Collection&lt;T&gt; collection, String separator);</span><br><span class="line">String joinToString(Collection&lt;T&gt; collection);</span><br></pre></td></tr></table></figure><h2 id="최상위-함수"><a href="#최상위-함수" class="headerlink" title="최상위 함수"></a>최상위 함수</h2><p>코틀린의 함수는 최상위 레벨이다. 자바에서는 클래스가 최상위 레벨이므로 모든 함수는 클래스 내부에 포함되어야 했다. 그렇기 때문에 공통 함수들을 포함하는 클래스들을 매번 생성해줘야 하므로 불필요한 클래스가 만들어졌다. 코틀린은 앞서 설명했든 함수가 최상위 레벨이므로 클래스를 만들지 않고 원하는 파일에 작성하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin, join.kt 파일</span></span><br><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(...)</span></span>: String &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinKt</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static String joinToString(...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린에서 작성한 함수는 자바로 변경될 때 <code>파일명이 클래스가 되며 그 안에 함수를 포함</code>시킨다. 만약 파일명이 클래스명으로 사용되기 싫다면 <code>@JvmName</code> 애노테이션을 해당 파일의 제일 앞(package보다)에 위치하면 된다.</p><h2 id="확장-함수"><a href="#확장-함수" class="headerlink" title="확장 함수"></a>확장 함수</h2><p>코틀린에서 제공하는 개념으로 <code>확장 함수</code>는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다. 아래의 예를 보면 쉽게 이해할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 생략</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>이 예는 문자열의 마지막 문자를 돌려주는 메소드이다. 실제로 String 클래스에는 lastChar가 없다. 하지만 마치 String의 멤버 함수인 것처럼 다른 곳에서 lastChar 함수를 사용할 수 있다.</p><p>확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다. 클래스 이름을 <code>수신 객체 타입</code>이라 부르며, 확장 함수가 호출되는 대상이 되는 값을 <code>수신 객체</code>라고 부른다. 위 예제에서는 String이 수신 객체 타입이며 this가 수신 객체이다. 또한 확장 함수는 클래스의 캡슐화를 깨지 않도록 <code>private, protected</code>멤버는 사용할 수 없다.</p><p>그리고 확장 함수는 수신 객체의 멤버 함수보다 레벨이 낮다. 수신 객체의 멤버 함수와 이름이 동일할 때 확장 함수가 아닌 멤버 함수가 호출된다. 그러므로 확장 함수를 만들 때엔 항상 클래스의 API를 염두 해 둬야 한다.</p><h3 id="자바에서-확장-함수-호출"><a href="#자바에서-확장-함수-호출" class="headerlink" title="자바에서 확장 함수 호출"></a>자바에서 확장 함수 호출</h3><p>내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. 그래서 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다. 확장 함수도 일반 함수와 마찬가지로 자바에서 호출 시 파일 이름에 따라 결정된다. 따라서 확장 함수를 StringUtil.kt 파일에 정의했다면 다음과 같이 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">char c = StringUtilsKt.lastChar(<span class="string">"java"</span>)</span><br></pre></td></tr></table></figure><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/28/first-funtion-definition-and-call/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Kotlin] 코틀린의 기초 2</title>
      <link>https://kmdigit.github.io/2020/03/26/second-basic-kotlin/</link>
      <guid>https://kmdigit.github.io/2020/03/26/second-basic-kotlin/</guid>
      <pubDate>Thu, 26 Mar 2020 11:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://kmdigit.github.io/2020/03/25/first-basic-kotlin/&quot;&gt;코틀린의 기초 1&lt;/a&gt;에 이어 코틀린의 기초 2를 시작한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;선택-표현과-처리-enum과-when&quot;&gt;&lt;a href=&quot;#선택-표현과-처리-enum과-when&quot; class=&quot;headerlink&quot; title=&quot;선택 표현과 처리: enum과 when&quot;&gt;&lt;/a&gt;선택 표현과 처리: enum과 when&lt;/h2&gt;&lt;h3 id=&quot;enum-클래스-정의&quot;&gt;&lt;a href=&quot;#enum-클래스-정의&quot; class=&quot;headerlink&quot; title=&quot;enum 클래스 정의&quot;&gt;&lt;/a&gt;enum 클래스 정의&lt;/h3&gt;&lt;p&gt;코틀린에서 enum은 소프트 키워드라 부르는 존재이다. enum은 class앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다. 반면 class는 키워드이므로 이름으로 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;자바와 마찬가지로 enum은 단순히 값만 열거하는 존재가 아니다. enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Color&lt;/span&gt; &lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; r: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; g: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; b: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  RED(&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ORANGE(&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;165&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  YELLOW(&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), GREEN(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), BLUE(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  INDIGO(&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;130&lt;/span&gt;), VILOET(&lt;span class=&quot;number&quot;&gt;238&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;130&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;238&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = (r * &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt; + g) * &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt; + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; println(Color.BLUE.rgb())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://kmdigit.github.io/2020/03/25/first-basic-kotlin/">코틀린의 기초 1</a>에 이어 코틀린의 기초 2를 시작한다.</p><hr><h2 id="선택-표현과-처리-enum과-when"><a href="#선택-표현과-처리-enum과-when" class="headerlink" title="선택 표현과 처리: enum과 when"></a>선택 표현과 처리: enum과 when</h2><h3 id="enum-클래스-정의"><a href="#enum-클래스-정의" class="headerlink" title="enum 클래스 정의"></a>enum 클래스 정의</h3><p>코틀린에서 enum은 소프트 키워드라 부르는 존재이다. enum은 class앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다. 반면 class는 키워드이므로 이름으로 사용할 수 없다.</p><p>자바와 마찬가지로 enum은 단순히 값만 열거하는 존재가 아니다. enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>(</span><br><span class="line">  <span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">  RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>),</span><br><span class="line">  YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), GREEN(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">  INDIGO(<span class="number">75</span>, <span class="number">0</span>, <span class="number">130</span>), VILOET(<span class="number">238</span>, <span class="number">130</span>, <span class="number">238</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(Color.BLUE.rgb())</span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>자바의 switch에 해당하는 코틀린 구성 요소는 <code>when</code>이다. if와 마찬가지로 when도 값을 만들어내는 식이므로 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다. 아래 예는 when과 enum을 사용하여 빨주노초파남보를 외우는 식이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMnemonic</span><span class="params">(color: <span class="type">Color</span>)</span></span> = </span><br><span class="line">  <span class="keyword">when</span>(color) &#123;</span><br><span class="line">    Color.RED -&gt; <span class="string">"Richard"</span></span><br><span class="line">    Color.ORANGE -&gt; <span class="string">"Of"</span></span><br><span class="line">    Color.YELLOW -&gt; <span class="string">"York"</span></span><br><span class="line">    Color.GREEN -&gt; <span class="string">"Gave"</span></span><br><span class="line">    Color.BLUE -&gt; <span class="string">"Battle"</span></span><br><span class="line">    Color.INDIGO -&gt; <span class="string">"In"</span></span><br><span class="line">    Color.VIOLET -&gt; <span class="string">"Vain"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"Other"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>자바와 다른 점은 <code>break</code> 를 넣지 않아도 되며 결과를 바로 리턴할 수 있는 식의 형태이다. 만약 여러개를 매치하기 위해서는 <code>,</code>를 사용하여 분리한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">GetMnemoic</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">  <span class="keyword">when</span>(color) &#123;</span><br><span class="line">    Color.RED, Color.YELLOW -&gt; <span class="string">"blah"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>코트린의 when은 임의의 개체를 사용하여 분기 처리도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mix</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">  <span class="keyword">when</span>(setOf(c1, c2)) &#123;</span><br><span class="line">    setOf(RED, YELLOW) -&gt; ORANGE</span><br><span class="line">    setOf(YELLOW, BLUE) -&gt; GREEN</span><br><span class="line">    setOf(BLUE, VIOLET) -&gt; INDIGO</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">"Dirty Color"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(mix(BLUE, YELLOW))</span><br><span class="line">GREEN</span><br></pre></td></tr></table></figure><p>또한 아예 인자가 없이도 사용이 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mixOptimized</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">  <span class="keyword">when</span> &#123;</span><br><span class="line">    (c1 == RED &amp;&amp; c2 == YELLOW) ||</span><br><span class="line">    (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;</span><br><span class="line">      ORANGE</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>when에 아무 인자도 없으려면 각 분기의 조건이 <code>Boolean 결과</code>를 계산하는 식이어야 한다.</p><h2 id="스마트-캐스트-타입-검사와-타입-캐스트를-조합"><a href="#스마트-캐스트-타입-검사와-타입-캐스트를-조합" class="headerlink" title="스마트 캐스트: 타입 검사와 타입 캐스트를 조합"></a>스마트 캐스트: 타입 검사와 타입 캐스트를 조합</h2><p>코틀린에서는 자바와는 다르게 타입 검사와 타입 캐스트가 동시에 이뤄진다. 자바의 경우 instanceof로 타입 검사 이후 캐스팅하여 사용을 해야하지만 코틀린에서는 검사와 동시에 캐스팅이 되어 그대로 변수를 사용이 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">if</span> (obj instanceof Person) &#123;</span><br><span class="line">  Person person = (Person) obj;</span><br><span class="line">  System.<span class="keyword">out</span>.println(person.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> Person) &#123;</span><br><span class="line">  println(obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="대상을-이터레이션"><a href="#대상을-이터레이션" class="headerlink" title="대상을 이터레이션"></a>대상을 이터레이션</h2><h3 id="while-루프"><a href="#while-루프" class="headerlink" title="while 루프"></a>while 루프</h3><p>코틀린에서는 <code>while</code>과 <code>do-while</code> 루프가 있다. 두 루프의 문법은 자바와 다르지 않다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건) &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125; <span class="keyword">while</span> (조건)</span><br></pre></td></tr></table></figure><h3 id="for-루프"><a href="#for-루프" class="headerlink" title="for 루프"></a>for 루프</h3><p>코틀린에서 <code>for 루프</code>는 변수의 초기화, 조건, 증분에 대한 요소가 없다. 자바와 동일한 반복문을 작성하기 위해서는 <code>range</code>라는 범위 키위둬를 사용한다. <code>range</code>는 기본적으로 두 값으로 이뤄진 구간이며 폐구간(양 끝을 포함하는) 이다. 사용법은 아래와 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) <span class="comment">// 1부터 100(포함) 범위의 정수에 대해 이터레이션</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">100</span> downTo <span class="number">1</span> step <span class="number">2</span>) <span class="comment">// 100부터 1(포함) 범위를 2씩 감소하며 이터레이션</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) <span class="comment">// 0부터 size(비포함)까지 이터레이션</span></span><br></pre></td></tr></table></figure><h3 id="맵에-대한-이터레이션"><a href="#맵에-대한-이터레이션" class="headerlink" title="맵에 대한 이터레이션"></a>맵에 대한 이터레이션</h3><p><code>for 루프</code>는 범위 뿐만 아니라 컬렉션에 대한 이터레이션도 가능하다. 이번에 보일 것은 키와 값으로 이뤄진 맵에 대한 이터레이션이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binaryRpes = TreeMap&lt;<span class="built_in">Char</span>, String&gt;()</span><br><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'F'</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> binary = Integer.toBinaryString(c.toInt())</span><br><span class="line">  binaryReps[c] = binary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((letter, binary) <span class="keyword">in</span> binaryReps) &#123;</span><br><span class="line">  println(<span class="string">"<span class="subst">$&#123;letter&#125;</span> = <span class="subst">$&#123;binary&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>숫자 뿐만 아니라 문자 타입에도 범위를 적용</li><li>자바에서의 맵과 사용법이 조금 다름  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">binaryReps.put(c, binary)</span><br><span class="line">binary = binaryReps.<span class="keyword">get</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">binaryReps[c] = binary</span><br><span class="line">binary = binaryReps[c]</span><br></pre></td></tr></table></figure></li></ul><p>위와 같이 맵에 대해 <code>for 루프</code>를 적용할 수 있으며 컬렉션에서도 활용이 가능하다. 컬렉션의 원소와 인덱스를 유지하면서 컬렉션을 이터레이션할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="string">"10"</span>, <span class="string">"11"</span>, <span class="string">"1001"</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> list) &#123;</span><br><span class="line">  println(<span class="string">"<span class="subst">$&#123;index&#125;</span> : <span class="subst">$&#123;element&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in으로-컬렉션이나-범위의-원소-검사"><a href="#in으로-컬렉션이나-범위의-원소-검사" class="headerlink" title="in으로 컬렉션이나 범위의 원소 검사"></a>in으로 컬렉션이나 범위의 원소 검사</h3><p><code>in 연산자</code>를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다. 반대로 <code>!in</code>을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span> || c <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c !<span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(isLetter(<span class="string">'q'</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(isNotDigit(<span class="string">'x'</span>))</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>위의 함수식을 <code>when</code>과 함께 사용하면 더 좋은 코드로 변경된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recognize</span><span class="params">(c: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span>(c) &#123;</span><br><span class="line">  <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span> -&gt; <span class="string">"It's a digit!"</span></span><br><span class="line">  <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span>, <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span> -&gt; <span class="string">"It's a letter!"</span></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="string">"I don't know"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(recognize(<span class="string">'8'</span>))</span><br><span class="line">It<span class="string">'s a digit!</span></span><br></pre></td></tr></table></figure><h2 id="코틀린의-예외-처리"><a href="#코틀린의-예외-처리" class="headerlink" title="코틀린의 예외 처리"></a>코틀린의 예외 처리</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try, catch, finally"></a>try, catch, finally</h3><p>자바와 마찬가지로 예외를 처리하려면 <code>try, catch, finally</code> 절을 함께 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.close</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">"239"</span>))</span><br><span class="line">&gt;&gt;&gt; println(readNumber(reader))</span><br><span class="line"><span class="number">239</span></span><br></pre></td></tr></table></figure><p>자바와 다른 점은 <code>catch</code>에서 지정하지 않은 다른 예외의 대한 처리이다. 자바에서는 명시적으로 <code>throws</code>를 통해 IOException, Exception 등 지정하지 않은 예외를 처리해야 했으나 코틀린에서는 최신의 JVM 언어와 마찬가지로 <code>체크 예외와 언체크 예외</code>를 두었다. 만약 언체크 예외가 발생했을 때 잡아내도 되고 잡아내지 않아도 되게끔 하였다. 그 이유는 프로그래머들이 의미 없는 예외를 다시 던지거나 잡는 불편함을 없애기 위함이다.</p><h3 id="try를-식으로-사용"><a href="#try를-식으로-사용" class="headerlink" title="try를 식으로 사용"></a>try를 식으로 사용</h3><p>앞서 설명했듯이 코틀린에서는 대부분이 식이다. 그러므로 <code>try</code>또한 식으로 사용할 수 있다. 앞에서 예들 들었던 코드를 식으로 처리할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">    Integer.parseInt(reader.readLine())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// &lt;- return 절 밑으로 실행하지 않으려면 return을 사용</span></span><br><span class="line">    <span class="literal">null</span> <span class="comment">// &lt;- 예외 발생시 계속 진행하고 싶다면 값을 반환</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/26/second-basic-kotlin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Kotlin] 코틀린의 기초 1</title>
      <link>https://kmdigit.github.io/2020/03/25/first-basic-kotlin/</link>
      <guid>https://kmdigit.github.io/2020/03/25/first-basic-kotlin/</guid>
      <pubDate>Wed, 25 Mar 2020 09:02:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;함수 선언은 &lt;code&gt;fun&lt;/code&gt; 키워드를 사용한다.&lt;/li&gt;
&lt;li&gt;파라미터는 &lt;code&gt;이름 → 타입&lt;/code&gt; 순서로 쓴다.&lt;/li&gt;
&lt;li&gt;코틀린에서 함수는 최상위 수준이다. 자바와 달리 클래스 안에 함수를 넣을 필요가 없다.
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>함수 선언은 <code>fun</code> 키워드를 사용한다.</li><li>파라미터는 <code>이름 → 타입</code> 순서로 쓴다.</li><li>코틀린에서 함수는 최상위 수준이다. 자바와 달리 클래스 안에 함수를 넣을 필요가 없다.<a id="more"></a></li></ul><h2 id="문-statement-과-식-expression"><a href="#문-statement-과-식-expression" class="headerlink" title="문(statement)과 식(expression)"></a>문(statement)과 식(expression)</h2><p>코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. 자바에서는 if는 문이지만 코틀린에서는 식인 것처럼 말이다. 여기서 식은 값을 만들어내고 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="식이-본문인-함수"><a href="#식이-본문인-함수" class="headerlink" title="식이 본문인 함수"></a>식이 본문인 함수</h3><p>코틀린에서는 식이 본문인 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다. 위에서 예제로 보인 식을 조금 더 단순하게 아래와 같이 표현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><ul><li>중괄호 삭제</li><li>return 삭제</li><li>리턴타입 삭제 → 타입 추론 : <code>식이 본문인 함의 반환 타입만 생략 가능</code></li></ul><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><h3 id="변경-불가능"><a href="#변경-불가능" class="headerlink" title="변경 불가능"></a>변경 불가능</h3><p>자바의 final과 동일하게 값을 뜻하는 value에서 따온 <code>val</code> 키워드를 사용한다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다.</p><p>val 변수는 블록을 실행할 때 정확히 한 번만 초기화해야 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message: String</span><br><span class="line"><span class="keyword">if</span> (canPerformOperation()) &#123;</span><br><span class="line">    message = <span class="string">"Success"</span></span><br><span class="line">    <span class="comment">// ... 연산 수행</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    message = <span class="string">"Failed"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languages = arrayListOf(<span class="string">"Java"</span>)</span><br><span class="line">languages.add(<span class="string">"Kotlin"</span>)</span><br></pre></td></tr></table></figure><h3 id="변경-가능"><a href="#변경-가능" class="headerlink" title="변경 가능"></a>변경 가능</h3><p>변수를 뜻하는 variable에서 따온 <code>var</code> 키워드를 사용한다. 이런 변수의 값은 바뀔 수 있으며 자바의 일반 변수에 해당한다.</p><h3 id="코틀린에선"><a href="#코틀린에선" class="headerlink" title="코틀린에선"></a>코틀린에선</h3><p>기본적으로는 모든 변수를 <code>val</code> 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 <code>var</code> 로 변경하길 권고한다. 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.</p><h2 id="문자열-템플릿"><a href="#문자열-템플릿" class="headerlink" title="문자열 템플릿"></a>문자열 템플릿</h2><p>로그나 정보를 출ㅋ력하기 위해 <code>println</code> 을 자주 사용하는데 이를 더욱 편리하게 해주는 코틀린의 기능이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="keyword">if</span> (args.size &gt; <span class="number">0</span>) args[<span class="number">0</span>] <span class="keyword">else</span> <span class="string">"Someone"</span></span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$name</span>"</span>) &lt;- 일반적인 방법</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;name&#125;</span> 반가워"</span>) &lt;- 추천하는 방법</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있도록 지원하고 있다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 <code>$</code> 를 추가해야 한다.</p><h3 id="코틀린에선-1"><a href="#코틀린에선-1" class="headerlink" title="코틀린에선"></a>코틀린에선</h3><p>자바와 마찬가지로 한글(글자로 분류할 수 있는 모든 유니코드 문자)을 식별자에 사용할 수 있으므로 변수 이름에 한글이 들어갈 수 있어 변수 이름을 <code>{}</code> 로 감싸는 것을 추천한다.</p><h2 id="클래스와-프로퍼티"><a href="#클래스와-프로퍼티" class="headerlink" title="클래스와 프로퍼티"></a>클래스와 프로퍼티</h2><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>코틀린에서는 최신의 언어처럼 간결하게 기술할 수 있는 구문을 제공한다. 특히 <code>값 객체(value object, 코드가 없이 데이터만 저장하는 클래스)</code>의 경우 더욱 다이나믹 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><ul><li>public 가시성 변경자 삭제 : 코틀린에서는 <code>기본이 public</code></li><li>생성자 및 프로퍼티 삭제 : 기본으로 생성</li></ul><h3 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h3><p>자바에서는 필드와 접근자를 한대 묶어 프로퍼티(property)라고 부르며, 프로퍼티라는 개념을 활용하는 프레임워크가 많다. 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며 자바의 필드와 접근자 메소드를 완전히 대신한다. 앞에서 살펴본 변수 선언 방법과 마찬가지로 <code>val</code>로 선언한 프로퍼티는 <code>읽기 전용</code>이며, <code>var</code>로 선언한 프로퍼티는 <code>변경 가능</code>이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(</span><br><span class="line">  <span class="keyword">val</span> name: String,</span><br><span class="line">  <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> person = Person(<span class="string">"funlee"</span>, <span class="literal">true</span>)</span><br><span class="line">  println(person.name) <span class="comment">// funlee</span></span><br><span class="line">  println(person.isMarried) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  person.isMarreid = <span class="literal">false</span></span><br><span class="line">  println(person.isMarried) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린에서는 게터(getter)를 호출하는 대신 프로퍼티를 직접 사용하여 더 간결해졌다.</p><h3 id="커스텀-접근자"><a href="#커스텀-접근자" class="headerlink" title="커스텀 접근자"></a>커스텀 접근자</h3><p>코틀린에서 제공하는 기본 접근자도 있지만 사용자가 직접 구현이 가능한 커스텀 접근자도 제공하고 있다. 예로 정사각형인지 알려주는 기능이 포함된 Rectangle 클래스는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> height == width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optimized</span></span><br><span class="line">    <span class="keyword">get</span>() = height == width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식 중 어느 쪽이 더 나은지 궁금할 수 있는데 두 방식 모두 비슷하다. 구현이나 성능상의 차이는 없고 차이가 나는 부분은 그저 <code>가독성</code>뿐이다.</p><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/25/first-basic-kotlin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Kotlin] 코틀린이란</title>
      <link>https://kmdigit.github.io/2020/03/23/what-is-kotlin/</link>
      <guid>https://kmdigit.github.io/2020/03/23/what-is-kotlin/</guid>
      <pubDate>Mon, 23 Mar 2020 10:44:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;코틀린&quot;&gt;&lt;a href=&quot;#코틀린&quot; class=&quot;headerlink&quot; title=&quot;코틀린&quot;&gt;&lt;/a&gt;코틀린&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;자바 플랫폼에서 돌아가는 프로그래밍 언어&lt;/li&gt;
&lt;li&gt;간결하고 실용적이며, 자바 코드와의 상호운용성을 중시&lt;/li&gt;
&lt;li&gt;자바가 사용되는 곳이라면 코틀린으로 활용 가능&lt;/li&gt;
&lt;li&gt;기존의 자바 라이브러리나 프레임워크와 함께 잘 작동하며 성능도 자바와 같은 수준
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="코틀린"><a href="#코틀린" class="headerlink" title="코틀린"></a>코틀린</h2><ul><li>자바 플랫폼에서 돌아가는 프로그래밍 언어</li><li>간결하고 실용적이며, 자바 코드와의 상호운용성을 중시</li><li>자바가 사용되는 곳이라면 코틀린으로 활용 가능</li><li>기존의 자바 라이브러리나 프레임워크와 함께 잘 작동하며 성능도 자바와 같은 수준<a id="more"></a></li></ul><h2 id="코틀린의-주요-특성"><a href="#코틀린의-주요-특성" class="headerlink" title="코틀린의 주요 특성"></a>코틀린의 주요 특성</h2><h3 id="정적-타입-statically-typed-지정-언어"><a href="#정적-타입-statically-typed-지정-언어" class="headerlink" title="정적 타입(statically typed) 지정 언어"></a>정적 타입(statically typed) 지정 언어</h3><p>모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해준다.</p><p>JVM에서의 동적 타입(dynamically typed) 지정 언어인 그루비, JRuby는 메소드나 필드 접근에 대한 검증이 실행 시점에 일어나며, 그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있다. 하지만 반대로 이름을 잘못 입력하는 등의 실수도 컴파일 시 걸러내지 못하고 실행 시점에 오류가 발생한다.</p><p>대신 코틀린에서는 자바와 달리 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 타입 선언을 생략할 수 있다. 이를 타입 추론(type interence)라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span> <span class="comment">// typed Int</span></span><br></pre></td></tr></table></figure><p>정적 타입은 아래의 장점을 갖는다.</p><ul><li>성능</li><li>신뢰성</li><li>유지 보수성</li><li>도구 지원</li></ul><h3 id="함수형-프로그래밍과-객체지향-프로그래밍"><a href="#함수형-프로그래밍과-객체지향-프로그래밍" class="headerlink" title="함수형 프로그래밍과 객체지향 프로그래밍"></a>함수형 프로그래밍과 객체지향 프로그래밍</h3><p>코틀린은 객체지향 뿐만 아니라 함수형 프로그램이도 지원하고 있다. (자바는 8이상부터 가능했다)<br>함수형 프로그래밍의 핵심 개념은 다음과 같다.</p><ul><li><p>일급 시민(first-class)인 함수<br>  함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.</p></li><li><p>불변성(immutalbility)<br>  함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그래밍을 작성한다.</p></li><li><p>부수 효과(side effect) 없음<br>  함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수(pure function)를 사용한다.</p></li></ul><p>위와 같은 함수형 프로그래밍을 하게 되면 다음과 같은 장점을 얻을 수 있다.</p><ul><li><p>간결함<br>  일반적인 명령형 코드에 비해 더 간결하고 우아하다.</p></li><li><p>추상화<br>  함수를 값처럼 활용할 수 있으면 더 강력한 추상화를 할 수 있고 강력한 추상화를 사용해 코드 중복을 막을 수 있다.</p></li><li><p>스레드 세이프<br>  함수형 프로그래밍의 개념 중 불변성에 의해 다중 스레드 프로그램에서 적절한 동기화 없이도 안전한 프로그래밍을 할 수 있다.</p></li></ul><h2 id="코틀린의-철학"><a href="#코틀린의-철학" class="headerlink" title="코틀린의 철학"></a>코틀린의 철학</h2><h3 id="실용성"><a href="#실용성" class="headerlink" title="실용성"></a>실용성</h3><p>코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어이며 연구를 위한 언어가 아니다. 코틀린은 다년간의 IT업계 경험을 바탕으로 이뤄졌으며, 소프트웨어 개발자들의 사용에 잘 들어맞을 수 있게 주의 깊게 언어 특성을 선택했다.</p><h3 id="간결성"><a href="#간결성" class="headerlink" title="간결성"></a>간결성</h3><p>코틀린을 만들면서 프로그래머가 작성하는 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 별 뜻은 없지만 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 했다. 그 예로 Getter, Setter, Constructor 등 자바에 존재하는 여러가지 번거로운 준비 코드를 코틀린은 묵시적으로 제공한다.</p><h3 id="안전성"><a href="#안전성" class="headerlink" title="안전성"></a>안전성</h3><p>일반적인 프로그램에서는 안전성과 생산성 사이의 트레이드오프 관계가 성립한다. 코틀린은 이러한 트레이드오프에서 높은 수준의 안전성을 달성하되 전체 비용은 더 적게 들기 위한 노력을 했다. 애초에 JVM위에서 작동하는 언어이므로 메모리 안전성이나, 버퍼 오버플로를 방지와 같은 기본적인 다양한 문제를 예방할 수 있다. 여기에 코틀린은 타입 추론을 통한 개발자의 실수를 줄일 수 있게 하였다. 한 걸음 더 나아가서는 NullPointerException을 없애기 위해 null에 대한 허용을 제한할 수 있다.</p><h3 id="상호운용성"><a href="#상호운용성" class="headerlink" title="상호운용성"></a>상호운용성</h3><p>코틀린은 자바 라이브러리를 어떠한 장치도 필요없이 그대로 사용이 가능하다. 자바로 된 프로젝트에 코틀린을 적용할 수 있으며 코틀린 프로젝트에도 자바를 적용해도 무리없이 동작이 가능하다.</p><p>출처 : <a href="http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=270227254&gclid=CjwKCAjwvOHzBRBoEiwA48i6Aggp3L98kGG8FHSR4tUN_HhRDdGXWo6cw21536Fyc9wxxMGynqv3oxoCnXkQAvD_BwE" rel="external nofollow noopener noreferrer" target="_blank">Kotlin in Acation</a></p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/23/what-is-kotlin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring] InfluxDB 커스텀으로 다른 DB 사용하기</title>
      <link>https://kmdigit.github.io/2020/03/21/custom-influxdb-configuration-on-spring/</link>
      <guid>https://kmdigit.github.io/2020/03/21/custom-influxdb-configuration-on-spring/</guid>
      <pubDate>Sat, 21 Mar 2020 05:33:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Multiple-DB-on-Spring&quot;&gt;&lt;a href=&quot;#Multiple-DB-on-Spring&quot; class=&quot;headerlink&quot; title=&quot;Multiple DB on Spring&quot;&gt;&lt;/a&gt;Multiple DB on Spring&lt;/h1&gt;&lt;p&gt;스프링에서 멀티로 데이터베이스를 사용하기 위해서는 따로 Datasource를 설정해야 한다.&lt;br&gt;InfluxDB도 마찬가지라 멀티 데이터소스를 설정하여 사용하도록 한다.  &lt;/p&gt;
&lt;h1 id=&quot;Based-influxDB-configuration&quot;&gt;&lt;a href=&quot;#Based-influxDB-configuration&quot; class=&quot;headerlink&quot; title=&quot;Based influxDB configuration&quot;&gt;&lt;/a&gt;Based influxDB configuration&lt;/h1&gt;&lt;p&gt;InfluxDB를 스프링에서 사용하기 위해서 앞에서 소개했던 &lt;code&gt;spring-data-influxdb&lt;/code&gt;(&lt;a href=&quot;https://kmdigit.github.io/2020/03/20/using-influxdb-spring/&quot;&gt;스프링부트에서 InfluxDB 사용하기&lt;/a&gt;)의 클래스를 먼저 알아야한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Multiple-DB-on-Spring"><a href="#Multiple-DB-on-Spring" class="headerlink" title="Multiple DB on Spring"></a>Multiple DB on Spring</h1><p>스프링에서 멀티로 데이터베이스를 사용하기 위해서는 따로 Datasource를 설정해야 한다.<br>InfluxDB도 마찬가지라 멀티 데이터소스를 설정하여 사용하도록 한다.  </p><h1 id="Based-influxDB-configuration"><a href="#Based-influxDB-configuration" class="headerlink" title="Based influxDB configuration"></a>Based influxDB configuration</h1><p>InfluxDB를 스프링에서 사용하기 위해서 앞에서 소개했던 <code>spring-data-influxdb</code>(<a href="https://kmdigit.github.io/2020/03/20/using-influxdb-spring/">스프링부트에서 InfluxDB 사용하기</a>)의 클래스를 먼저 알아야한다.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.influxdb"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBProperties</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(InfluxDBProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">InfluxDBConfiguration</span></span></span><br></pre></td></tr></table></figure><p><code>InfluxDBConfiguration</code> 클래스는 InfluxDB를 사용하기 위해 application.yml에 작성해 둔 influxdb 설정으로 다양한 Bean들을 등록한다. 이때 사용하게 되는 클래스가 <code>InfluxDBProperties</code>인데 이 클래스는 기본적으로 yml파일의 <code>spring.influxdb</code>를 prefix로 둔 설정정보를 읽도록 돼있다.<br>즉 influxdb를 멀티로 설정하기 위해서는 해당 클래스의 prefix와 이를 사용하여 Bean을 등록하는 클래스를 수정하면 된다.</p><h2 id="InfluxDBProperties"><a href="#InfluxDBProperties" class="headerlink" title="InfluxDBProperties"></a>InfluxDBProperties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.multi-influxdb"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBPropertiesMulti</span> <span class="keyword">extends</span> <span class="title">InfluxDBProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 yaml파일의 prefix를 수정하고 이를 읽어 기본 정보를 설정하는 <code>InfluxDBProperties</code> 클래스를 재정의 한다.<br>방법은 쉬운데 <code>InfluxDBProperties</code>를 상속받아 자신이 원하는 이름의 클래스를 하나 더 만들어 등록하는 것이다. 본문 내용은 특별히 설정할 것이 없으므로 클래스만 정의하도록 한다.</p><h2 id="InfluxDBConfiguration"><a href="#InfluxDBConfiguration" class="headerlink" title="InfluxDBConfiguration"></a>InfluxDBConfiguration</h2><p><code>InfluxDBProperties</code>를 설정하였으니 이제 이를 사용하여 Bean을 등록하는 InfluxDBConfiguration을 정의하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(InfluxDBPropertiesMulti<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">InfluxDBConfigurationMulti</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"connectionFactoryMulti"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InfluxDBConnectionFactory <span class="title">connectionFactory</span><span class="params">(<span class="keyword">final</span> InfluxDBPropertiesMulti properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InfluxDBConnectionFactory(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"influxDBTemplateMulti"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InfluxDBTemplate&lt;Point&gt; <span class="title">influxDBTemplate</span><span class="params">(@Qualifier(<span class="string">"connectionFactoryMulti"</span>)</span> <span class="keyword">final</span> InfluxDBConnectionFactory connectionFactory) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * You can use your own 'PointCollectionConverter' implementation, e.g. in case</span></span><br><span class="line"><span class="comment">         * you want to use your own custom measurement object.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InfluxDBTemplate&lt;&gt;(connectionFactory, <span class="keyword">new</span> PointConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"defaultTemplateMulti"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultInfluxDBTemplate <span class="title">defaultTemplate</span><span class="params">(@Qualifier(<span class="string">"connectionFactoryMulti"</span>)</span> <span class="keyword">final</span> InfluxDBConnectionFactory connectionFactory) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If you are just dealing with Point objects from 'influxdb-java' you could</span></span><br><span class="line"><span class="comment">         * also use an instance of class DefaultInfluxDBTemplate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultInfluxDBTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음에 소개했던 <code>InfluxDBConfiguration</code>과 거의 흡사하다. 다른점이라고는 <code>@EnableConfigurationProperties</code>에 위에서 작성한 <code>InfluxDBProeprtiesMulti</code>클래스를 설정하고 Bean으로 등록하는 이름을 원하는 이름으로 지정하며 이를 주입받는 클래스에 <code>@Qualifier</code>로 Bean을 지정해주면 된다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>사용법도 기존과 동일하다. yaml파일에 작성한 설정정보를 자동으로 읽어 지정한 이름으로 Bean을 등록하였으므로 <code>InfluxDBTemplate</code>에 주입받는 Bean의 이름만 <code>@Qualifier</code>로 지정해주면 끝이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBServiceMulti</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InfluxDBTemplate&lt;Point&gt; influxDBTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HdfsCoreServiceImpl</span><span class="params">(@Qualifier(<span class="string">"influxDBTemplateMulti"</span>)</span> InfluxDBTemplate&lt;Point&gt; influxDBTemplate) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.influxDBTemplate = influxDBTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/21/custom-influxdb-configuration-on-spring/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring] 스프링부트에서 InfluxDB 사용하기</title>
      <link>https://kmdigit.github.io/2020/03/20/using-influxdb-spring/</link>
      <guid>https://kmdigit.github.io/2020/03/20/using-influxdb-spring/</guid>
      <pubDate>Fri, 20 Mar 2020 07:12:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;InfluxDB&quot;&gt;&lt;a href=&quot;#InfluxDB&quot; class=&quot;headerlink&quot; title=&quot;InfluxDB&quot;&gt;&lt;/a&gt;InfluxDB&lt;/h1&gt;&lt;p&gt;NoSQL중에 오픈소스 시계열 데이터베이스로 Go언어로 개발이 됐다. 시계열 데이터의 저장 및 검색 기능에 최적화 돼있다.&lt;/p&gt;
&lt;h1 id=&quot;스프링에서는&quot;&gt;&lt;a href=&quot;#스프링에서는&quot; class=&quot;headerlink&quot; title=&quot;스프링에서는?&quot;&gt;&lt;/a&gt;스프링에서는?&lt;/h1&gt;&lt;p&gt;InfluxDB 자체에서 따로 API를 제공하지만 일일이 다 찾아 사용하기 어려우므로 현재 제대로 제공하고 있는 오픈 라이브러리를 적용하면 사용하기 쉽다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h1><p>NoSQL중에 오픈소스 시계열 데이터베이스로 Go언어로 개발이 됐다. 시계열 데이터의 저장 및 검색 기능에 최적화 돼있다.</p><h1 id="스프링에서는"><a href="#스프링에서는" class="headerlink" title="스프링에서는?"></a>스프링에서는?</h1><p>InfluxDB 자체에서 따로 API를 제공하지만 일일이 다 찾아 사용하기 어려우므로 현재 제대로 제공하고 있는 오픈 라이브러리를 적용하면 사용하기 쉽다.</p><a id="more"></a><h2 id="influxdb-java-or-influxdb-client-java"><a href="#influxdb-java-or-influxdb-client-java" class="headerlink" title="influxdb-java(or influxdb-client-java)"></a>influxdb-java(or influxdb-client-java)</h2><p><a href="https://github.com/influxdata/influxdb-java" rel="external nofollow noopener noreferrer" target="_blank">influxdb-java</a>는 <code>influxdb 1.x</code>일 때 사용가능하며 <a href="https://github.com/influxdata/influxdb-client-java" rel="external nofollow noopener noreferrer" target="_blank">influxdb-client-java</a>는 <code>2.x</code>부터 사용가능하다.<br>influxdata에서 공식적으로 제공하는 라이브러리로 <code>Connector, POJO</code>등 다양한 기능들을 제공한다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.influxdb:influxdb-java:2.17'</span></span><br><span class="line">implementation <span class="string">'org.influxdb:influxdb-client-java:1.6.0'</span></span><br></pre></td></tr></table></figure><h2 id="spring-data-influxdb"><a href="#spring-data-influxdb" class="headerlink" title="spring-data-influxdb"></a>spring-data-influxdb</h2><p>스프링에서 쉽게 사용할 수 있도록 만들어진 라이브러리. (<a href="https://github.com/miwurster/spring-data-influxdb" rel="external nofollow noopener noreferrer" target="_blank">github</a>)<br>개인이 만들었으며 <code>application.yml</code>에 influxdb관련 설정을 할 수 있도록 도와준다.<br><code>spring-data-influxdb</code>는 기본적으로 <code>influxdb-java</code>를 내포하고 있으므로 그냥 사용해도 되나 버전업이 조금 늦으므로 최신 버전을 사용하려면 따로 추가해줘야 한다.</p><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><h3 id="라이브러리-추가"><a href="#라이브러리-추가" class="headerlink" title="라이브러리 추가"></a>라이브러리 추가</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.yml</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'com.fasterxml.jackson.core:jackson-databind:2.10.2'</span></span><br><span class="line">    implementation <span class="string">'com.github.miwurster:spring-data-influxdb:1.8'</span></span><br><span class="line">    implementation <span class="string">'org.influxdb:influxdb-java:2.17'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="influxdb-설정"><a href="#influxdb-설정" class="headerlink" title="influxdb 설정"></a>influxdb 설정</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  influxdb:</span><br><span class="line">    url: http:&#x2F;&#x2F;localhost:8086</span><br><span class="line">    username: user</span><br><span class="line">    password: ~</span><br><span class="line">    database: test</span><br><span class="line">    retention-policy: autogen</span><br></pre></td></tr></table></figure><h3 id="spring-data-influxdb-설정"><a href="#spring-data-influxdb-설정" class="headerlink" title="spring-data-influxdb 설정"></a>spring-data-influxdb 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(InfluxDBProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">InfluxDBConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InfluxDBConnectionFactory <span class="title">connectionFactory</span><span class="params">(@Qualifier(<span class="string">"spring.influxdb-org.springframework.data.influxdb.InfluxDBProperties"</span>)</span> <span class="keyword">final</span> InfluxDBProperties properties) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InfluxDBConnectionFactory(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InfluxDBTemplate&lt;Point&gt; <span class="title">influxDBTemplate</span><span class="params">(<span class="keyword">final</span> InfluxDBConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * You can use your own 'PointCollectionConverter' implementation, e.g. in case</span></span><br><span class="line"><span class="comment">         * you want to use your own custom measurement object.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InfluxDBTemplate&lt;&gt;(connectionFactory, <span class="keyword">new</span> PointConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultInfluxDBTemplate <span class="title">defaultTemplate</span><span class="params">(<span class="keyword">final</span> InfluxDBConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If you are just dealing with Point objects from 'influxdb-java' you could</span></span><br><span class="line"><span class="comment">         * also use an instance of class DefaultInfluxDBTemplate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultInfluxDBTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InfluxDBTemplate-사용"><a href="#InfluxDBTemplate-사용" class="headerlink" title="InfluxDBTemplate 사용"></a>InfluxDBTemplate 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxServiceImpl</span> <span class="keyword">implements</span> <span class="title">InfluxService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InfluxDBTemplate&lt;Point&gt; influxDBTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfluxServiceImpl</span><span class="params">(InfluxDBTemplate&lt;Point&gt; influxDBTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.influxDBTemplate = influxDBTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        influxDBTemplate.createDatabase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(CPU cpu)</span> </span>&#123;</span><br><span class="line">        influxDBTemplate.write(Point.measurementByPOJO(CPU<span class="class">.<span class="keyword">class</span>).<span class="title">addFieldsFromPOJO</span>(<span class="title">cpu</span>).<span class="title">build</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>influxdb-java</code>가 <code>POJO</code>를 지원하므로 필요한 데이터를 클래스로 구현하여 사용하면 편리하다.</p><h3 id="Measurement-구현"><a href="#Measurement-구현" class="headerlink" title="Measurement 구현"></a>Measurement 구현</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Measurement</span>(name = <span class="string">"cpu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TimeColumn</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"tiem"</span>)</span><br><span class="line">    <span class="keyword">private</span> Instant time;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"version"</span>)</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"use"</span>)</span><br><span class="line">    <span class="keyword">private</span> String use;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"idle"</span>)</span><br><span class="line">    <span class="keyword">private</span> String idle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>influxdb</code>는 시계열 데이터베이스이므로 시간이 중요한 포인트이므로 <code>@TimeColumn, Instant</code>로 시간을 제공할 수 있다.</p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/20/using-influxdb-spring/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring] 웹소켓에서 가상의 유저(Principal) 생성하기(no Security)</title>
      <link>https://kmdigit.github.io/2020/03/19/assign-user-on-websocket-springboot/</link>
      <guid>https://kmdigit.github.io/2020/03/19/assign-user-on-websocket-springboot/</guid>
      <pubDate>Thu, 19 Mar 2020 07:08:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;웹소켓에서의-유저&quot;&gt;&lt;a href=&quot;#웹소켓에서의-유저&quot; class=&quot;headerlink&quot; title=&quot;웹소켓에서의 유저&quot;&gt;&lt;/a&gt;웹소켓에서의 유저&lt;/h2&gt;&lt;p&gt;스프링 시큐리티(Spring Security)를 사용하는 웹서버의 경우 사용자 정보를 사용하여 인증을 진행하게 되는데 이때 클라이언트의 경우에도 자신의 고유 정보를 통해 사용자 정보와 매칭할 수 있다.&lt;br&gt;만약 시큐리티(Security)를 사용하지 않을 경우 &lt;code&gt;messagingTemplate.convertAndSendToUser&lt;/code&gt;함수를 사용 시 &lt;code&gt;sessionId&lt;/code&gt;를 사용해야 하는 불편함이 있는데 이럴 때 가상의 사용자를 생성하면 편하게 사용할 수 있 게 된다.  &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="웹소켓에서의-유저"><a href="#웹소켓에서의-유저" class="headerlink" title="웹소켓에서의 유저"></a>웹소켓에서의 유저</h2><p>스프링 시큐리티(Spring Security)를 사용하는 웹서버의 경우 사용자 정보를 사용하여 인증을 진행하게 되는데 이때 클라이언트의 경우에도 자신의 고유 정보를 통해 사용자 정보와 매칭할 수 있다.<br>만약 시큐리티(Security)를 사용하지 않을 경우 <code>messagingTemplate.convertAndSendToUser</code>함수를 사용 시 <code>sessionId</code>를 사용해야 하는 불편함이 있는데 이럴 때 가상의 사용자를 생성하면 편하게 사용할 수 있 게 된다.  </p><a id="more"></a><h3 id="유저-생성"><a href="#유저-생성" class="headerlink" title="유저 생성"></a>유저 생성</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignPrincipalHandshakeHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandshakeHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Principal <span class="title">determineUser</span><span class="params">(ServerHttpRequest request, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        String name = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Principal() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="유저-생성-핸들러-사용"><a href="#유저-생성-핸들러-사용" class="headerlink" title="유저 생성 핸들러 사용"></a>유저 생성 핸들러 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StompWebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">"/websocket"</span>)</span><br><span class="line">                .setHandshakeHandler(<span class="keyword">new</span> AssignPrincipalHandshakeHandler())</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="클라이언트-접속-시-유저-확인"><a href="#클라이언트-접속-시-유저-확인" class="headerlink" title="클라이언트 접속 시 유저 확인"></a>클라이언트 접속 시 유저 확인</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionEventListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSessionConnected</span><span class="params">(SessionConnectedEvent event)</span> </span>&#123;</span><br><span class="line">        StompHeaderAccessor accessor</span><br><span class="line">                = MessageHeaderAccessor.getAccessor(</span><br><span class="line">                (GenericMessage)event.getMessage().getHeaders().get(<span class="string">"simpConnectMessage"</span>), StompHeaderAccessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String userId = accessor.getUser().getName();</span><br><span class="line">        String sessionId = accessor.getSessionId();</span><br><span class="line">        System.out.println(<span class="string">"userId = "</span> + userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/19/assign-user-on-websocket-springboot/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Java] 익명 클래스에서 람다 함수로 변경</title>
      <link>https://kmdigit.github.io/2020/03/17/from-java-anonymous-class-to-single-line-lambda/</link>
      <guid>https://kmdigit.github.io/2020/03/17/from-java-anonymous-class-to-single-line-lambda/</guid>
      <pubDate>Tue, 17 Mar 2020 05:08:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;익명-클래스&quot;&gt;&lt;a href=&quot;#익명-클래스&quot; class=&quot;headerlink&quot; title=&quot;익명 클래스&quot;&gt;&lt;/a&gt;익명 클래스&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;anomymousClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String hello = FUNLEE.callHello(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Hello() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt; + name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.out.println(hello);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="익명-클래스"><a href="#익명-클래스" class="headerlink" title="익명 클래스"></a>익명 클래스</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anomymousClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String hello = FUNLEE.callHello(<span class="keyword">new</span> Hello() -&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="함수-이름-제거"><a href="#함수-이름-제거" class="headerlink" title="함수 이름 제거"></a>함수 이름 제거</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anomymousClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String hello = FUNLEE.callHello((String name) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="파라미터-타입-제거"><a href="#파라미터-타입-제거" class="headerlink" title="파라미터 타입 제거"></a>파라미터 타입 제거</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anomymousClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String hello = FUNLEE.callHello(name -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="리턴문-제거"><a href="#리턴문-제거" class="headerlink" title="리턴문 제거"></a>리턴문 제거</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anomymousClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String hello = FUNLEE.callHello(name -&gt; <span class="string">"Hello, "</span> + name);</span><br><span class="line"></span><br><span class="line">  System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunleeService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FunleeRepository repo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Funlee <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repo.findById(id).orElseGet(Funlee::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optional.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; supplier)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value != <span class="keyword">null</span> ? <span class="keyword">this</span>.value : supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supplier.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Optional</code> 클래스의 <code>orElseGet</code> 함수의 파라미터는 <code>Supplier</code>를 상속받아 구현한 객체를 받고 있으며 <code>Supplier</code> 클래스는 함수가 하나 뿐인 인터페이스로 <code>@FunctionalInterface</code> 어노테이션이 작성돼 있다. 자바에서는 하나의 함수만 존재하는 인터페이스에 한해서 람다(lambda)로 변경할 수 있도록 지원해주고 있으므로 예제와 같이 <code>Funlee::new</code>와 같은 람다 호출이 가능하다.</p><p>만약 람다식으로 호출하지 않는다면 다음과 같이 풀어서 작성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Funlee <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> repo.findById(id).orElseGet(<span class="keyword">new</span> Supplier&lt;Funlee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Funlee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Funlee();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/17/from-java-anonymous-class-to-single-line-lambda/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring] WebSocket 특정 유저로 메세지 보내기</title>
      <link>https://kmdigit.github.io/2020/03/12/send-message-direct-user-in-spring-websocket/</link>
      <guid>https://kmdigit.github.io/2020/03/12/send-message-direct-user-in-spring-websocket/</guid>
      <pubDate>Thu, 12 Mar 2020 12:40:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;서버&quot;&gt;&lt;a href=&quot;#서버&quot; class=&quot;headerlink&quot; title=&quot;서버&quot;&gt;&lt;/a&gt;서버&lt;/h2&gt;&lt;p&gt;웹소켓을 사용하여 서버에서 특정 유저로 메세지를 전달하는 방법은 두 가지인데 하나는 브로커를 통한 메세지 전달, 다른 하나는 직접 전달이다.&lt;/p&gt;
&lt;p&gt;브로커를 통한 전달은 &lt;code&gt;@SendToUser&lt;/code&gt;을 사용하여 쉽게 전달할 수 있으나 직접 전달 시에는 &lt;code&gt;SimpMessagingTemplate&lt;/code&gt;으로 전달할 수 있다. 방법은 아래와 같다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="서버"><a href="#서버" class="headerlink" title="서버"></a>서버</h2><p>웹소켓을 사용하여 서버에서 특정 유저로 메세지를 전달하는 방법은 두 가지인데 하나는 브로커를 통한 메세지 전달, 다른 하나는 직접 전달이다.</p><p>브로커를 통한 전달은 <code>@SendToUser</code>을 사용하여 쉽게 전달할 수 있으나 직접 전달 시에는 <code>SimpMessagingTemplate</code>으로 전달할 수 있다. 방법은 아래와 같다.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StompController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(“/direct”)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">directSendMessage</span><span class="params">(@RequestParam String user)</span> </span>&#123;</span><br><span class="line">    messagingTemplate.convertAndSendToUser(user, “/queue/message”, <span class="keyword">new</span> DirectMessage(“test”), createHeaders(<span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MessageHeaders <span class="title">createHeaders</span><span class="params">(@Nullable String sessionId)</span> </span>&#123;</span><br><span class="line">    SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);</span><br><span class="line">    <span class="keyword">if</span> (sessionId != <span class="keyword">null</span>) headerAccessor.setSessionId(sessionId);</span><br><span class="line">    headerAccessor.setLeaveMutable(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> headerAccessor.getMessageHeaders();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>messagingTemplate.convertAndSendToUser</code>는 @SendToUser와 다르게 헤더정보가 없으므로 직접 입력해주어야 한다.</li><li><code>createHeaders</code>함수는 필요한 헤더를 설정해주며 만약 세션아이디로 특정 유저에게 메세지를 전달 할 때 세션아이디로 전송할 수 있도록 헤더에 설정해준다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sessionId로 전달 시</span></span><br><span class="line">messagingTemplate.convertAndSendToUser(sessionId, “/queue/message”, <span class="keyword">new</span> DirectMessage(“test”), createHeaders(sessionId));</span><br></pre></td></tr></table></figure></li><li><code>createHeaders</code>함수는 <code>SendToMethodReturnValueHandler.java</code>를 참고하였고 해당 클래스에는 더 자세하고 많은 기능들을 알 수 있다.</li></ul><h2 id="클라이언트"><a href="#클라이언트" class="headerlink" title="클라이언트"></a>클라이언트</h2><p>클라이언트가 브로커를 통해서가 아닌 직접 메세지를 받기 위해서는 구독 시 주소 앞에 <code>/user</code>이 붙어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 브로커를 통한 메세지 수신 @SendToUser</span></span><br><span class="line">session.subscribe(“/queue/message”, brokerMessageHandler);</span><br><span class="line"><span class="comment">// 직접 메세지 수신 convertAndSendToUser</span></span><br><span class="line">session.subscribe(“/user/queue/message”, directMessageHandler);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/12/send-message-direct-user-in-spring-websocket/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Spring Security] 컨트롤러에서 사용자 정보 얻어오기</title>
      <link>https://kmdigit.github.io/2020/03/10/get-principal-on-controller-in-spring-security/</link>
      <guid>https://kmdigit.github.io/2020/03/10/get-principal-on-controller-in-spring-security/</guid>
      <pubDate>Tue, 10 Mar 2020 08:57:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;메서드-인자-Principal&quot;&gt;&lt;a href=&quot;#메서드-인자-Principal&quot; class=&quot;headerlink&quot; title=&quot;메서드 인자 (Principal)&quot;&gt;&lt;/a&gt;메서드 인자 (Principal)&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/index&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Pricipal principal)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;username = &quot;&lt;/span&gt; + principal.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="메서드-인자-Principal"><a href="#메서드-인자-Principal" class="headerlink" title="메서드 인자 (Principal)"></a>메서드 인자 (Principal)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(Pricipal principal)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"username = "</span> + principal.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="메서드-인자-Authentication"><a href="#메서드-인자-Authentication" class="headerlink" title="메서드 인자 (Authentication)"></a>메서드 인자 (Authentication)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">    UserDetails userDetails = (UserDetails)authentication.getPrincipal();</span><br><span class="line">    System.out.println(<span class="string">"username = "</span> + userDetails.getUsername());</span><br><span class="line">    System.out.println(<span class="string">"role = "</span> + userDetails.getAuthorities().stream().map(r -&gt; String.valueOf(r)).collect(Collectors.joining(<span class="string">","</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(Pricipal principal)</span> </span>&#123;</span><br><span class="line">    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    UserDetails userDetails = (UserDetails)principal;</span><br><span class="line">    String username = principal.getUsername();</span><br><span class="line">    String password = principal.getPassword();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationPrincipal"><a href="#AuthenticationPrincipal" class="headerlink" title="@AuthenticationPrincipal"></a>@AuthenticationPrincipal</h3><p>Spring Security 3.2부터 지원하며 UserDetails를 구현한 클래스와 UserDetailsService를 구현한 서비스가 있을 때 정상동작을 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(@AuthenticationPrincipal Member member)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"username = "</span> + member.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> Member implements UserDetails &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSevice</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberRepository.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/10/get-principal-on-controller-in-spring-security/#disqus_thread</comments>
    </item>
    
    <item>
      <title>인텔리J 스프링부트 프로젝트 멀티 실행</title>
      <link>https://kmdigit.github.io/2020/03/06/IntelliJ-SpringBoot-Project-Multiple-Run/</link>
      <guid>https://kmdigit.github.io/2020/03/06/IntelliJ-SpringBoot-Project-Multiple-Run/</guid>
      <pubDate>Fri, 06 Mar 2020 03:02:00 GMT</pubDate>
      <description>
      
        &lt;ol&gt;
&lt;li&gt;Menu -&amp;gt; Run -&amp;gt; Edit Configurations 클릭&lt;/li&gt;
&lt;li&gt;Add New Configuration(+, Command + N) -&amp;gt; Spring Boot 클릭&lt;/li&gt;
&lt;li&gt;멀티 실행하고자 하는 프로젝트의 정보 복사
      
      </description>
      
      
      <content:encoded><![CDATA[<ol><li>Menu -&gt; Run -&gt; Edit Configurations 클릭</li><li>Add New Configuration(+, Command + N) -&gt; Spring Boot 클릭</li><li>멀티 실행하고자 하는 프로젝트의 정보 복사<a id="more"></a><ul><li>만약 포트번호가 필요할 경우 <code>VM Options</code>에 포트 정보 입력<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver-port&#x3D;8081</span><br></pre></td></tr></table></figure><img src="/images/pasted-0.png" alt="Edit Configurations 설정"></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/03/06/IntelliJ-SpringBoot-Project-Multiple-Run/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo 블로그 만들기 (with icarus)</title>
      <link>https://kmdigit.github.io/2020/02/27/Hexo-blog-open-with-icarus/</link>
      <guid>https://kmdigit.github.io/2020/02/27/Hexo-blog-open-with-icarus/</guid>
      <pubDate>Thu, 27 Feb 2020 14:55:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;기본-준비물&quot;&gt;&lt;a href=&quot;#기본-준비물&quot; class=&quot;headerlink&quot; title=&quot;기본 준비물&quot;&gt;&lt;/a&gt;기본 준비물&lt;/h2&gt;&lt;h3 id=&quot;node-js&quot;&gt;&lt;a href=&quot;#node-js&quot; class=&quot;headerlink&quot; title=&quot;node.js&quot;&gt;&lt;/a&gt;node.js&lt;/h3&gt;&lt;p&gt;node 사이트가 아닌 nvm으로 설치.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; .bash_profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ nvm install stable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="기본-준비물"><a href="#기본-준비물" class="headerlink" title="기본 준비물"></a>기본 준비물</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>node 사이트가 아닌 nvm으로 설치.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</span><br><span class="line">$ <span class="built_in">source</span> .bash_profile</span><br><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h2 id="hexo-설치"><a href="#hexo-설치" class="headerlink" title="hexo 설치"></a>hexo 설치</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>hexo 설치 후 원하는 폴더에서 아래 명령어를 실행.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="icarus-테마-설치"><a href="#icarus-테마-설치" class="headerlink" title="icarus 테마 설치"></a>icarus 테마 설치</h2><p><code>hexo init</code> 이후 생성 된 <code>theme</code>폴더에 <code>icarus</code>테마를 아래 명령어로 복사.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br></pre></td></tr></table></figure><p>모두 다운받은 후엔 블로그 최상위 폴더의 <code>_config.yml</code>에 다음과 같이 수정.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: icarus</span><br></pre></td></tr></table></figure><p>이후 <code>hexo server</code> 명령어를 실행하면 <code>cheerio</code>가 없다며 에러가 발생하니 바로 설치.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cheerio</span><br></pre></td></tr></table></figure><p>다시 <code>hexo server</code>를 실행하면 테마인 <code>icarus</code>폴더에 <code>_config.yml</code>이 없다며 생성됨.</p><h2 id="hexo-admin-설치"><a href="#hexo-admin-설치" class="headerlink" title="hexo-admin 설치"></a>hexo-admin 설치</h2><p>hexo-admin은 hexo에서 제공하는 플러그인으로 글을 쓸 수 있도록 에디팅을 지원함.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure><p>설치 된 이후 서버를 실행하고 아래의 주소로 접속하면 에디팅할 수 있는 웹 페이지를 제공함.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;admin</span><br></pre></td></tr></table></figure><h2 id="블로그-백업"><a href="#블로그-백업" class="headerlink" title="블로그 백업"></a>블로그 백업</h2><p>총 2개의 github private repository가 필요.</p><ul><li>blog (<a href="https://github.com/kmdigit/blog.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kmdigit/blog.git</a>)</li><li>icarus (<a href="https://github.com/kmdigit/icarus.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kmdigit/icarus.git</a>)</li></ul><p>총 두 개의 저장소를 생성.</p>]]></content:encoded>
      
      <comments>https://kmdigit.github.io/2020/02/27/Hexo-blog-open-with-icarus/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
